<!DOCTYPE html>
<html lang="es" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Yu-Gi-Oh! Combo maker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.6/purify.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    
    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>

    <style>
        :root {
            --color-primary: #3b82f6; /* blue-500 */
            --color-primary-hover: #2563eb; /* blue-600 */
            --color-secondary: #a78bfa; /* violet-400 */
            --color-accent: #f59e0b; /* amber-500 */
            --color-background: #f1f5f9; /* slate-100 */
            --color-surface: #ffffff; /* white */
            --color-surface-light: #f8fafc; /* slate-50 */
            --color-text: #0f172a; /* slate-900 */
            --color-text-muted: #64748b; /* slate-500 */
            --color-danger: #ef4444; /* red-500 */
            --color-warning: #f59e0b; /* amber-500 */
        }

        [data-theme="dark"] {
            --color-primary: #8b5cf6; /* violet-500 */
            --color-primary-hover: #7c3aed; /* violet-600 */
            --color-secondary: #a78bfa; /* violet-400 */
            --color-accent: #fcd34d; /* amber-300 */
            --color-background: #020617; /* slate-950 */
            --color-surface: #1e293b; /* slate-800 */
            --color-surface-light: #334155; /* slate-700 */
            --color-text: #e2e8f0; /* slate-200 */
            --color-text-muted: #94a3b8; /* slate-400 */
            --color-danger: #ef4444; /* red-500 */
            --color-warning: #fcd34d; /* amber-300 */
        }
        
        #bg-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -10;
            background-color: var(--color-background);
        }

        body {
            font-family: 'Inter', Arial, sans-serif;
            color: var(--color-text);
            background-color: transparent; /* Make body transparent to see canvas */
            transition: background-color 0.3s ease;
            zoom: 0.9; /* Adjusts the default zoom of the entire page */
        }
        .font-yugioh {
            font-family: 'Cinzel Decorative', 'Times New Roman', serif;
            text-shadow: 0 0 5px var(--color-secondary), 0 0 10px var(--color-secondary);
        }
        .font-yugi-title {
            font-family: 'Cinzel Decorative', 'Times New Roman', serif;
            text-shadow: 0 0 8px var(--color-accent), 0 0 12px var(--color-accent);
        }
        
        #splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            opacity: 1;
            transition: opacity 1s ease-out;
        }
        #splash-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: var(--color-surface); border-radius: 10px; }
        ::-webkit-scrollbar-thumb { background: var(--color-surface-light); border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: #64748b; }
        
        .btn, details, summary, .card-display, .combo-step-card, section h3, .rich-text-editor .toolbar button, .notification, .toast {
            transition: all 0.3s ease;
        }
        .btn:active {
            transform: scale(0.95);
        }

        .drag-over {
            outline: 3px dashed var(--color-accent) !important;
            background-color: rgba(245, 158, 11, 0.2) !important;
            transform: scale(1.02);
            box-shadow: 0 0 20px rgba(245, 158, 11, 0.5);
        }
        .dragging {
            opacity: 0.4;
            transform: scale(0.95);
            cursor: grabbing !important;
        }
        #export-container {
            position: absolute;
            left: -9999px;
            top: auto;
            width: 1280px;
        }
        .spinner {
            border: 2px solid #4a5568;
            border-top: 2px solid var(--color-primary);
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .card-highlight {
            box-shadow: 0 0 15px 3px var(--color-primary), 0 0 25px 5px var(--color-secondary);
            transform: scale(1.05);
        }
        .step-incomplete {
            box-shadow: 0 0 8px 1px var(--color-warning);
        }
        .step-vulnerable {
            box-shadow: 0 0 12px 2px var(--color-danger), 0 0 20px 4px rgba(239, 68, 68, 0.5);
            border-color: var(--color-danger);
        }
        
        .notification.show { opacity: 1; transform: translateY(0); }
        .notification.hide { opacity: 0; transform: translateY(-20px); }

        .card-enter {
            transform: scale(0.8);
            opacity: 0;
            transition: transform 0.3s ease-out, opacity 0.3s ease-out;
        }
        .card-enter-active {
            transform: scale(1);
            opacity: 1;
        }

        #card-hover-preview {
            position: fixed;
            z-index: 1100;
            width: 320px;
            background-color: rgba(12, 10, 21, 0.85);
            backdrop-filter: blur(5px);
            border: 2px solid var(--color-secondary);
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            padding: 1rem;
            opacity: 0;
            transform: scale(0.95) translateY(10px);
            transition: opacity 0.2s ease, transform 0.2s ease;
            pointer-events: none;
        }
        #card-hover-preview.visible {
            opacity: 1;
            transform: scale(1) translateY(0);
        }

        #touch-drag-ghost {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            opacity: 0.8;
            transform-origin: center center;
        }
        
        #app-tooltip {
            visibility: hidden;
            background-color: var(--color-surface);
            color: var(--color-text);
            text-align: center;
            border-radius: 6px;
            padding: 8px 12px;
            position: fixed;
            z-index: 1010;
            opacity: 0;
            transition: opacity 0.3s;
            border: 1px solid var(--color-surface-light);
            font-size: 0.875rem;
            max-width: 200px;
            pointer-events: none;
        }
        #app-tooltip.visible {
            visibility: visible;
            opacity: 1;
        }

        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }
        @keyframes zoomIn { from { transform: scale(0.95); } to { transform: scale(1); } }
        @keyframes zoomOut { from { transform: scale(1); } to { transform: scale(0.95); } }
        @keyframes fadeInUp { from { opacity: 0; transform: translateY(15px); } to { opacity: 1; transform: translateY(0); } }

        .modal-enter { animation: fadeIn 0.3s ease-out forwards; }
        .modal-enter .modal-content { animation: zoomIn 0.3s ease-out forwards; }
        .modal-exit { animation: fadeOut 0.3s ease-in forwards; }
        .modal-exit .modal-content { animation: zoomOut 0.3s ease-in forwards; }
        .animate-fadeInUp { animation: fadeInUp 0.5s ease-out forwards; }

        .card-skeleton {
            background-color: var(--color-surface-light);
            border-radius: 0.375rem;
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: .5; } }

        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 2rem;
            border: 2px dashed var(--color-border);
            border-radius: 0.5rem;
            min-height: 11rem;
            color: var(--color-text-muted);
            width: 100%;
        }
        .empty-state i { font-size: 2.5rem; margin-bottom: 1rem; }
        .empty-state h4 { font-weight: 600; font-size: 1.125rem; color: var(--color-text); }

        .tutorial-overlay { position: fixed; inset: 0; z-index: 1000; }
        .tutorial-spotlight { position: fixed; border-radius: 8px; box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.7); transition: all 0.3s ease-in-out; pointer-events: none; }
        .tutorial-tooltip { position: fixed; background-color: var(--color-surface); color: var(--color-text); padding: 1rem; border-radius: 8px; border: 1px solid var(--color-surface-light); box-shadow: 0 5px 15px rgba(0,0,0,0.3); max-width: 320px; transition: all 0.3s ease-in-out; }
        
        #app-footer {
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }
        #app-footer.visible {
            visibility: visible;
            opacity: 1;
        }
    
        /* --- Single, centered diagonal watermark --- */
        .export-onewm { position: relative !important; }
        /* Watermark element we can measure & scale */
        #export-wm {
          position: absolute;
          inset: 0;
          pointer-events: none;
          z-index: 0;
          display: flex;
          align-items: center;
          justify-content: center;
        }
        #export-wm > div {
          font-family: 'Cinzel Decorative', 'Times New Roman', serif;
          font-weight: 700;
          text-transform: uppercase;
          letter-spacing: 0.2em;
          white-space: nowrap;
          opacity: 0.08;
          -webkit-text-stroke: 1px rgba(0,0,0,0.15);
          text-shadow: 2px 2px 8px rgba(0,0,0,0.35);
          transform: rotate(-30deg) scale(1);
          transform-origin: 50% 50%;
          font-size: 110px;
        }

        /* Fix for html2canvas rendering bugs */
        [data-exporting="1"] .export-onewm,
        [data-exporting="1"] .export-onewm * {
          white-space: normal !important;
          letter-spacing: 0.5px !important; /* Force space between letters */
          text-rendering: geometricPrecision;
        }

        [data-exporting="1"] .font-yugioh, 
        [data-exporting="1"] .font-yugi-title {
            font-family: 'Cinzel Decorative', 'Times New Roman', serif !important;
            text-shadow: none !important;
        }

        /* Do not block clicks with hover preview */
        #card-hover-preview,
        .hover-preview,
        [data-hover-preview] { pointer-events: none !important; }

        /* Hide tooltip when empty */
        #app-tooltip:empty { display: none !important; visibility: hidden !important; }

        /* === Responsive steps grid backdrop === */
        .export-onewm [data-steps-grid]{
          width:100%;
          overflow:visible;
        }

        /* === Export steps: pack columns, overlay arrows === */
        .export-onewm .export-arrow{
          position:absolute;
          right:-12px;
          top:50%;
          transform:translateY(-50%);
          font-weight:700;
          font-size:1.5rem;
          color:#a78bfa;
          pointer-events:none;
        }
        .export-onewm .grid[style*="grid-template-columns"]{ width:100%; }

        .ygo-field-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            grid-template-rows: repeat(4, 1fr);
            gap: 4px;
            width: 100%;
            max-width: 450px;
            aspect-ratio: 1.5;
            background-color: rgba(0,0,0,0.2);
            padding: 8px;
            border-radius: 8px;
        }

        .ygo-field-zone {
            background-color: var(--color-surface-light);
            border: 1px solid var(--color-primary);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.65rem;
            font-weight: bold;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .ygo-field-zone:hover {
            background-color: var(--color-primary);
            color: white;
            transform: scale(1.05);
        }

        .zone-mmz { grid-column: span 1; }
        .zone-stz { grid-column: span 1; }

        /* Grid layout for zones */
        .grid-pos-emz1 { grid-area: 1 / 2 / 2 / 3; }
        .grid-pos-emz2 { grid-area: 1 / 4 / 2 / 5; }
        .grid-pos-fz { grid-area: 1 / 6 / 2 / 7; }

        .grid-pos-mmz1 { grid-area: 2 / 1 / 3 / 2; }
        .grid-pos-mmz2 { grid-area: 2 / 2 / 3 / 3; }
        .grid-pos-mmz3 { grid-area: 2 / 3 / 3 / 4; }
        .grid-pos-mmz4 { grid-area: 2 / 4 / 3 / 5; }
        .grid-pos-mmz5 { grid-area: 2 / 5 / 3 / 6; }
        
        .grid-pos-gy { grid-area: 2 / 6 / 3 / 7; }

        .grid-pos-stz1 { grid-area: 3 / 1 / 4 / 2; }
        .grid-pos-stz2 { grid-area: 3 / 2 / 4 / 3; }
        .grid-pos-stz3 { grid-area: 3 / 3 / 4 / 4; }
        .grid-pos-stz4 { grid-area: 3 / 4 / 4 / 5; }
        .grid-pos-stz5 { grid-area: 3 / 5 / 4 / 6; }
        
        .grid-pos-bp { grid-area: 3 / 6 / 4 / 7; }

    </style>
</head>
<body
>
    <div id="app-container"></div>
    <div id="export-container"></div>
    <div id="card-hover-preview-container"></div>
    <div id="touch-drag-ghost-container"></div>
    <div id="app-tooltip"></div>

    <footer id="app-footer" class="text-center text-slate-400 py-8 px-4 space-y-4">
        <div class="max-w-2xl mx-auto space-y-4">
            <details class="bg-[var(--color-surface)] p-4 rounded-lg text-left shadow-md">
                <summary class="cursor-pointer font-semibold text-[var(--color-secondary)]">Frequently Asked Questions (FAQ)</summary>
                <div class="p-2 space-y-3 text-sm border-t border-[var(--color-border)] mt-2">
                    <p><strong>P: ¿Cómo guardo mi combo?</strong><br/>R: Usa el botón de Guardar (ícono de disquete) o presiona Ctrl+S. Si estás conectado, se guardará en la nube. De lo contrario, se te pedirá un nombre y se guardará en tu navegador.</p>
                    <p><strong>P: ¿La imagen exportada no se ve bien?</strong><br/>R: En las opciones de exportación, intenta seleccionar una calidad de imagen "Alta". Esto aumentará el tamaño del archivo pero mejorará la resolución.</p>
                    <p><strong>P: ¿Puedo compartir mi combo con un amigo?</strong><br/>R: ¡Sí! Usa el botón de enlace para copiar una URL única de tu combo a tu portapapeles y compártela con quien quieras.</p>
                    <p><strong>P: ¿Se guardó mi combo si cerré la pestaña?</strong><br/>R: ¡Sí! La aplicación autoguarda tu progreso cada 10 segundos. Cuando regreses, se te preguntará si quieres restaurarlo.</p>
                </div>
            </details>
            <details class="bg-[var(--color-surface)] p-4 rounded-lg text-left shadow-md">
                <summary class="cursor-pointer font-semibold text-[var(--color-secondary)]">Reportar un Problema / Sugerencia</summary>
                
                <div class="p-2 border-t border-[var(--color-border)] mt-2">
                  <div class="space-y-3">
                    <p class="text-sm">
                      ¿Tienes un bug o sugerencia? Envíalo como <strong>Issue de GitHub</strong> en tu repositorio.
                    </p>

                    <div class="grid gap-3 md:grid-cols-2">
                      <div>
                        <label class="text-xs block mb-1">Repo Owner</label>
                        <input id="gh-owner" class="w-full p-2 bg-[var(--color-surface-light)] border border-[var(--color-border)] rounded-lg focus:ring-2 focus:ring-[var(--color-primary)] focus:outline-none text-sm" placeholder="ej. aaoollaaooll"/>
                      </div>
                      <div>
                        <label class="text-xs block mb-1">Repo Name</label>
                        <input id="gh-repo" class="w-full p-2 bg-[var(--color-surface-light)] border border-[var(--color-border)] rounded-lg focus:ring-2 focus:ring-[var(--color-primary)] focus:outline-none text-sm" placeholder="ej. yugioh-combo-maker"/>
                      </div>
                    </div>

                    <div class="grid gap-3 md:grid-cols-2">
                      <div>
                        <label class="text-xs block mb-1">Tipo</label>
                        <select id="gh-type" class="w-full p-2 bg-[var(--color-surface-light)] border border-[var(--color-border)] rounded-lg text-sm">
                          <option value="bug">Bug</option>
                          <option value="enhancement">Sugerencia</option>
                          <option value="question">Pregunta</option>
                        </select>
                      </div>
                      <div>
                        <label class="text-xs block mb-1">Título</label>
                        <input id="gh-title" class="w-full p-2 bg-[var(--color-surface-light)] border border-[var(--color-border)] rounded-lg focus:ring-2 focus:ring-[var(--color-primary)] focus:outline-none text-sm" placeholder="[Bug] Descripción corta"/>
                      </div>
                    </div>

                    <textarea 
                      id="gh-body"
                      class="w-full p-2 bg-[var(--color-surface-light)] border border-[var(--color-border)] rounded-lg focus:ring-2 focus:ring-[var(--color-primary)] focus:outline-none text-sm" 
                      rows="5" 
                      placeholder="Describe el problema o tu idea.">
                    </textarea>

                    <div class="flex flex-wrap gap-2">
                      <button type="button" onclick="YGOH_GH_OPEN_ISSUE()" class="btn px-4 py-2 bg-[var(--color-primary)] text-white font-semibold rounded-lg hover:bg-[var(--color-primary-hover)] transition-colors shadow-md text-sm">
                        Abrir Issue en GitHub
                      </button>
                      <a id="gh-view-issues" href="#" target="_blank" class="btn px-4 py-2 bg-[var(--color-surface-light)] text-[var(--color-text)] font-semibold rounded-lg hover:bg-slate-600/40 transition-colors shadow-md text-sm">
                        Ver Issues
                      </a>
                    </div>
                    <p id="gh-status" class="text-xs text-[var(--color-text-muted)]"></p>
                  </div>
                </div>
                <script>
                (function(){
                  var GH_DEFAULT_OWNER = '';
                  var GH_DEFAULT_REPO  = '';

                  function detectFromURL(){
                    try {
                      var host = location.hostname || '';
                      var parts = (location.pathname || '/').split('/').filter(Boolean);
                      if (host.endsWith('github.io') && parts.length > 0) {
                        var owner = host.split('.')[0];
                        var repo  = parts[0];
                        return { owner: owner, repo: repo };
                      }
                    } catch(e){}
                    return null;
                  }
                  function loadStored(){
                    try {
                      var owner = localStorage.getItem('ygo_gh_owner') || '';
                      var repo  = localStorage.getItem('ygo_gh_repo')  || '';
                      if (owner || repo) return { owner: owner, repo: repo };
                    } catch(e){}
                    return null;
                  }
                  function saveStored(owner, repo){
                    try {
                      localStorage.setItem('ygo_gh_owner', owner || '');
                      localStorage.setItem('ygo_gh_repo',  repo  || '');
                    } catch(e){}
                  }
                  function enc(s){ return encodeURIComponent(s || ''); }
                  function buildTitle(){
                    var title = document.getElementById('gh-title')?.value || '';
                    var type = document.getElementById('gh-type')?.value || '';
                    if (!title) title = (type ? '[' + type + '] ' : '') + 'Nuevo reporte';
                    return title;
                  }
                  function buildBody(){
                    var body = (document.getElementById('gh-body')?.value || '').trim();
                    var meta = [
                      '',
                      '---',
                      'App: YGOH Combo Maker',
                      'URL: ' + location.href,
                      'User-Agent: ' + navigator.userAgent
                    ].join('\n');
                    return (body ? body + '\n' : '') + meta;
                  }
                  function updateIssuesLink(owner, repo){
                    var view = document.getElementById('gh-view-issues');
                    if (view && owner && repo) {
                      view.href = 'https://github.com/' + owner + '/' + repo + '/issues';
                    }
                  }
                  window.YGOH_GH_OPEN_ISSUE = function(){
                    var owner = (document.getElementById('gh-owner')?.value || '').trim();
                    var repo  = (document.getElementById('gh-repo')?.value  || '').trim();
                    var type  = (document.getElementById('gh-type')?.value  || '').trim();
                    if (!owner || !repo){
                      var s = document.getElementById('gh-status');
                      if (s) s.textContent = 'Completa Owner y Repo.';
                      return;
                    }
                    saveStored(owner, repo);
                    var labels = type ? type : '';
                    var url = 'https://github.com/' + owner + '/' + repo + '/issues/new'
                              + '?title=' + enc(buildTitle())
                              + '&body=' + enc(buildBody())
                              + (labels ? '&labels=' + enc(labels) : '');
                    window.open(url, '_blank', 'noopener');
                    updateIssuesLink(owner, repo);
                  };
                  document.addEventListener('DOMContentLoaded', function(){
                    var $owner = document.getElementById('gh-owner');
                    var $repo  = document.getElementById('gh-repo');
                    var fromStore = loadStored();
                    var fromURL   = detectFromURL();
                    var owner = (fromStore && fromStore.owner) || (fromURL && fromURL.owner) || GH_DEFAULT_OWNER || '';
                    var repo  = (fromStore && fromStore.repo)  || (fromURL && fromURL.repo)  || GH_DEFAULT_REPO  || '';
                    if ($owner && !$owner.value) $owner.value = owner;
                    if ($repo  && !$repo.value)  $repo.value  = repo;
                    updateIssuesLink(owner, repo);
                  });
                })();
                </script>

                    </form>
                </div>
            </details>
        </div>
        <div class="text-xs text-[var(--color-text-muted)] mt-6">
            <p>Created by YGO-Dev © 2024. This is a fan project.</p>
            <p>Yu-Gi-Oh! and all related materials are copyright ©2020 Studio Dice/SHUEISHA, TV TOKYO, KONAMI.</p>
        </div>
    </footer>

    <script type="text/babel">
        // --- Global mouse tracker for precise hover positioning ---
        (function(){
            if (!window.__YGO_MOUSE__) {
                window.__YGO_MOUSE__ = { x: 0, y: 0 };
                window.addEventListener('mousemove', function(e){
                    window.__YGO_MOUSE__.x = e.clientX;
                    window.__YGO_MOUSE__.y = e.clientY;
                }, { passive: true });
            }
        })();

        // --- Starfield generator for export background ---
        function __hashSeed(s){ s=String(s||''); var h=2166136261>>>0; for(var i=0;i<s.length;i++){ h^=s.charCodeAt(i); h=Math.imul(h,16777619)>>>0;} return h>>>0; }
        function __rng(seed){ var x=(seed>>>0)||1; return function(){ x^=x<<13; x^=x>>>17; x^=x<<5; return ((x>>>0)/4294967296);} }
        function generateStarfieldDataURL(host){
            try{
                host=host||document.querySelector('.export-onewm'); if(!host) return null;
                var r=host.getBoundingClientRect(); var W=Math.max(320,Math.floor(r.width)), H=Math.max(320,Math.floor(r.height));
                var salt = host && host.dataset ? (host.dataset.starSalt || '') : '';
                var key=salt+'|'+W+'x'+H; if(host.dataset.starKey===key && host.dataset.starUrl){ return host.dataset.starUrl; }
                var seedStr=(host.getAttribute('data-wm-text')||'')+'|'+key; var rand=__rng(__hashSeed(seedStr));
                var c=document.createElement('canvas'); c.width=W; c.height=H; var ctx=c.getContext('2d',{willReadFrequently:true});
                var g=ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#0a0f1a'); g.addColorStop(1,'#0b1020'); ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
                function neb(cx,cy,r,rgba){ var rg=ctx.createRadialGradient(cx,cy,0,cx,cy,r); rg.addColorStop(0,rgba.replace(',1)',',0.18)')); rg.addColorStop(0.4,rgba.replace(',1)',',0.10)')); rg.addColorStop(1,'rgba(0,0,0,0)'); ctx.globalCompositeOperation='lighter'; ctx.fillStyle=rg; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill(); ctx.globalCompositeOperation='source-over'; }
                var nN=2+Math.floor(rand()*2); var hues=[[168,246,1],[200,180,1],[286,180,1]];
                for(var i=0;i<nN;i++){ var cx=(0.2+0.6*rand())*W, cy=(0.2+0.6*rand())*H, rr=(0.25+0.35*rand())*Math.max(W,H), pick=hues[Math.floor(rand()*hues.length)]; var col='rgba('+pick[0]+','+pick[1]+','+Math.floor(200+55*rand())+',1)'; neb(cx,cy,rr,col); }
                function star(x,y,s,a,b){ ctx.save(); ctx.globalAlpha=a; ctx.fillStyle='rgba(255,255,255,1)'; ctx.shadowColor='rgba(255,255,255,0.9)'; ctx.shadowBlur=b; ctx.beginPath(); ctx.arc(x,y,s,0,Math.PI*2); ctx.fill(); ctx.restore(); }
                var area=W*H, base=Math.floor(area/18000), bright=Math.floor(base*0.18), mid=Math.floor(base*0.55), faint=Math.floor(base*0.90);
                for(var i=0;i<faint;i++){ star(rand()*W,rand()*H,0.4+rand()*0.6,0.35+rand()*0.2,0.3+rand()*0.6); }
                for(var i=0;i<mid;i++){ star(rand()*W,rand()*H,0.7+rand()*0.9,0.55+rand()*0.25,0.8+rand()*1.2); }
                for(var i=0;i<bright;i++){ star(rand()*W,rand()*H,1.2+rand()*1.1,0.85+rand()*0.15,1.6+rand()*2.2); }
                var vg=ctx.createRadialGradient(W/2,H/2,Math.min(W,H)*0.2,W/2,H/2,Math.max(W,H)*0.75); vg.addColorStop(0,'rgba(0,0,0,0)'); vg.addColorStop(1,'rgba(0,0,0,0.45)'); ctx.fillStyle=vg; ctx.fillRect(0,0,W,H);
                var url=c.toDataURL('image/png'); host.dataset.starKey=key; host.dataset.starUrl=url; return url;
            }catch(e){ return null; }
        }
        function setSmartExportBackground(host){
            try{
                host=host||document.querySelector('.export-onewm'); if(!host) return;
                var url=generateStarfieldDataURL(host);
                if(url){ host.style.backgroundImage='url('+url+')'; host.style.backgroundSize='cover'; host.style.backgroundPosition='center'; host.style.backgroundColor='#0a0f1a'; }
            }catch(e){}
        }

        window.__YGO_DRAGGING__ = false;

        const { useState, useEffect, useRef, useCallback, memo, useMemo, useLayoutEffect } = window.React;
        const { createRoot, createPortal } = window.ReactDOM;

        const StarfieldBackground = () => {
            useEffect(() => {
                const canvas = document.createElement('canvas');
                canvas.id = 'bg-canvas';
                document.body.prepend(canvas);
                const ctx = canvas.getContext('2d');
                let stars;
                let animationFrameId;

                function resizeCanvas() {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                }

                class Star {
                    constructor() {
                        this.x = Math.random() * canvas.width;
                        this.y = Math.random() * canvas.height;
                        this.z = Math.random() * canvas.width;
                    }

                    update() {
                        this.z -= 2;
                        if (this.z < 1) {
                            this.z = canvas.width;
                            this.x = Math.random() * canvas.width;
                            this.y = Math.random() * canvas.height;
                        }
                    }

                    show() {
                        let sx = (this.x - canvas.width / 2) * (canvas.width / this.z) + canvas.width / 2;
                        let sy = (this.y - canvas.height / 2) * (canvas.width / this.z) + canvas.height / 2;
                        let r = (canvas.width / this.z);
                        
                        if (sx > 0 && sx < canvas.width && sy > 0 && sy < canvas.height) {
                            ctx.beginPath();
                            ctx.arc(sx, sy, r, 0, Math.PI * 2);
                            const theme = document.documentElement.getAttribute('data-theme');
                            const starColor = theme === 'dark' ? '255, 255, 255' : '0, 0, 0';
                            ctx.fillStyle = `rgba(${starColor}, ${1 - this.z / canvas.width})`;
                            ctx.fill();
                        }
                    }
                }

                function setupStars() {
                    stars = [];
                    const starCount = Math.floor((canvas.width + canvas.height) / 4);
                    for (let i = 0; i < starCount; i++) {
                        stars.push(new Star());
                    }
                }

                function draw() {
                    const theme = document.documentElement.getAttribute('data-theme');
                    const bgColor = theme === 'dark' ? 'rgba(2, 6, 23, 0.5)' : 'rgba(241, 245, 249, 0.5)';
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    for (const star of stars) {
                        star.update();
                        star.show();
                    }
                    animationFrameId = requestAnimationFrame(draw);
                }

                function init() {
                    resizeCanvas();
                    setupStars();
                    draw();
                }

                const handleResize = () => {
                    cancelAnimationFrame(animationFrameId);
                    init();
                };
                
                init();
                window.addEventListener('resize', handleResize);
                
                const observer = new MutationObserver((mutations) => {
                    mutations.forEach((mutation) => {
                        if (mutation.type === 'attributes' && mutation.attributeName === 'data-theme') {
                           // Theme changed, no need to redraw immediately, draw loop handles it
                        }
                    });
                });
                observer.observe(document.documentElement, { attributes: true });


                return () => {
                    window.removeEventListener('resize', handleResize);
                    cancelAnimationFrame(animationFrameId);
                    observer.disconnect();
                    document.body.removeChild(canvas);
                };
            }, []);

            return null; // The canvas is managed directly in the DOM
        };

        const translations = {
            es: {
                mainTitle: "Yu-Gi-Oh! Guía de Combos", mainSubtitle: "Crea, visualiza y comparte tus combos de cartas.", undo: "Deshacer", redo: "Rehacer", exportPng: "Exportar como PNG", clearAll: "Limpiar Todo", addCardsTitle: "Añadir Cartas", searchPlaceholder: "Buscar por nombre...", loading: "Buscando cartas...", noCardsFound: "No se encontraron cartas con esos criterios o ya fueron agregadas.", searchError: "Error al buscar cartas.", comboPiecesTitle: "Pool de Cartas", comboPiecesPlaceholder: "Busca y añade cartas para empezar tu combo.", comboTitlePlaceholder: "Título del combo", startingHandTitle: "Mano Inicial", startingHandPlaceholder: "Arrastra cartas aquí para definir tu mano inicial.", comboStepsTitle: "Pasos del Combo", addStep: "Añadir Paso", addNote: "Agregar Nota", comboStepsPlaceholder: "Arrastra una carta o añade un paso nuevo.", finalBoardTitle: "Campo Final", addCard: "Añadir Carta", finalBoardPlaceholder: "Construye aquí tu campo final.", cardType: "Tipo", cardRace: "Raza", clearConfirmTitle: "¿Limpiar Guía de Combo?", clearConfirmMessage: "¿Seguro que quieres borrar todas las cartas y pasos? Esta acción no se puede deshacer.", confirm: "Confirmar", cancel: "Cancelar", cardSelectorSearch: "Buscar carta...", cardSelectorNoMatch: "No hay cartas que coincidan.", pngPreviewTitle: "Vista Previa del PNG", download: "Descargar", generatingPng: "Generando PNG...", exportError: "Error al exportar a PNG.", loadError: "No se pudo cargar el combo guardado.", ctxAddToHand: "Añadir a Mano Inicial", ctxAddStep: "Añadir a Paso", ctxAddFinalBoard: "Añadir a Campo Final", ctxViewCard: "Ver Carta", ctxDuplicateCard: "Duplicar Carta", ctxRemoveFromPool: "Quitar de Piezas", stepAffectedCards: "Cartas Afectadas:", stepDescribeAction: "Describe la acción...", finalBoardDisruption: "Disrupción", untitledCombo: "Combo Sin Título", cardAlreadyAdded: "La carta ya está en tus piezas.", cardAlreadyInPool: "Carta ya añadida", exportOptions: "Opciones de Exportación", include: "Incluir", notesTitle: "Notas y Estrategia", notesPlaceholder: "Escribe aquí tus notas, choke points, etc...", exportOptionsTitle: "Opciones de Exportación", confirmAndExport: "Confirmar y Exportar", addToken: "Añadir Token", tokenSearchError: "Error al buscar un token aleatorio.", filterBy: "Filtrar por:", filterArchetype: "Arquetipo", filterAttribute: "Atributo", filterLevel: "Nivel/Rango", filterType: "Tipo de Carta", clearFilters: "Limpiar Filtros", all: "Todos", cardSize: "Tamaño de Carta", show: "Añadir", hide: "Ocultar", saveAs: "Guardar", loadCombo: "Cargar Combo", share: "Compartir", saveComboTitle: "Guardar Combo", comboName: "Nombre del Combo", save: "Guardar", loadComboTitle: "Cargar Combo", noCombosSaved: "No hay combos guardados.", delete: "Borrar", deleteConfirmMessage: "¿Seguro que quieres borrar el combo '{comboName}'?", linkCopied: "¡Enlace copiado al portapapeles!", createCustomCard: "Crear Carta Personalizada", customCardTitle: "Crear Carta Personalizada", uploadImage: "Subir Imagen", cardName: "Nombre de la Carta", cardDescription: "Descripción", attack: "Ataque", defense: "Defensa", create: "Crear", preview: "Vista Previa", showPreview: "Mostrar Vista Previa",
                apiCheck: "Verificando conexión con la API...", apiCheckSuccess: "¡Conexión exitosa!", apiCheckFail: "No se pudo conectar a la API. Algunas funciones pueden estar limitadas.",
                exportLayout: "Diseño", exportLayoutGrid: "Grid", exportLayoutLines: "Líneas", exportLayoutSingleColumn: "1 Columna", exportQuality: "Calidad de Imagen", qualityLow: "Baja", qualityMedium: "Media", qualityHigh: "Alta",
                fetchingImages: "Descargando imágenes...",
                templates: "Plantillas", loadTemplate: "Cargar Plantilla", templateConfirm: "Esto reemplazará tu combo actual. ¿Continuar?", loadingTemplate: "Cargando plantilla...",
                cardNotes: "Notas de la Carta", saveNotes: "Guardar Notas",
                nextPage: "Siguiente", prevPage: "Anterior", page: "Página",
                navigation: "Navegación",
                helpDisruption: "Una 'disrupción' es cualquier acción que puedes realizar durante el turno de tu oponente para interrumpir su estrategia (ej. negar un efecto, destruir una carta).",
                helpStartingHand: "Las cartas con las que inicias el combo. Representan tu mano inicial o las cartas que tienes disponibles en el campo al comenzar.",
                stepBreadcrumb: "Paso {current} de {total}", stepLabel: "Paso", actionsMenu: "Acciones",
                cardZone: "Zona", location: "Ubicación", selectZone: "Seleccionar Zona",
                recentChanges: "Cambios Recientes", estimatedTime: "Tiempo estimado del combo: ~{time}s", background: "Fondo", cardPoolTitle: "Pool de Cartas",
                toggleConnector: "Cambiar Conector", actionOther: "Otro", stepAddTargetCard: "Añadir carta objetivo",
                addCardsToPoolFirst: "Primero añade cartas a tu 'Pool de Cartas' para empezar a construir el combo.", otherComboPieces: "Otras Piezas del Combo",
                addStartingGroup: "Añadir grupo (O)", addInitialHandGroup: "Añadir Mano Inicial", addAlternateHand: "Añadir Mano Alterna",
                notificationAdded: "¡Agregada!",
                tutorialNext: "Siguiente", tutorialSkip: "Omitir", tutorialFinish: "Finalizar",
                tutorialTitleSearch: "Panel de Búsqueda", tutorialContentSearch: "¡Bienvenido! Aquí puedes buscar cualquier carta de Yu-Gi-Oh! para añadirla a tu combo. Usa los filtros para refinar tu búsqueda.",
                tutorialTitlePopularCards: "Carrusel de Cartas Populares", tutorialContentPopularCards: "Aquí tienes una selección de cartas populares para un acceso rápido. Puedes navegar con las flechas y hacer clic en el título para ocultar/mostrar el carrusel.",
                tutorialTitlePool: "Pool de Cartas", tutorialContentPool: "Las cartas que añades desde la búsqueda aparecen aquí. Este es tu 'inventario' de cartas disponibles para construir el combo.",
                tutorialTitleHand: "Mano Inicial", tutorialContentHand: "Arrastra cartas desde tu 'Pool' aquí para definir tu mano inicial. Puedes añadir manos alternativas para diferentes escenarios.",
                tutorialTitleSteps: "Pasos del Combo", tutorialContentSteps: "Aquí es donde ocurre la magia. Arrastra una carta aquí para crear el primer paso de tu combo y describir la acción.",
                tutorialTitleFinalBoard: "Campo Final", tutorialContentFinalBoard: "Aquí armas el campo que dejas al final de tu combo. Marca las cartas que sirven como 'disrupción' para el turno del oponente.",
                tutorialTitleNotes: "Sección de Notas", tutorialContentNotes: "Usa este espacio para notas adicionales, estrategias o puntos débiles del combo.",
                tutorialTitleActions: "Guardar y Exportar", tutorialContentActions: "Usa estos botones para guardar tu combo localmente, compartirlo con un enlace, o exportarlo como una imagen para redes sociales.",
                tutorialTitleStepActionSelect: "Seleccionar Acción", tutorialContentStepActionSelect: "Usa este menú para elegir la acción principal del paso (Invocar, Activar, etc.).",
                tutorialTitleStepVulnerability: "Marcar Vulnerabilidad", tutorialContentStepVulnerability: "Haz clic en este botón⚠️ para marcar si este paso es vulnerable a una interrupción del oponente, como una 'handtrap'.",
                tutorialTitleStepAffectedCards: "Cartas Afectadas", tutorialContentStepAffectedCards: "Usa este botón [+] para añadir otras cartas que son objetivo o parte de la acción, como materiales de Fusión o Synchro.",
                tutorialTitleStepDescription: "Describir la Acción", tutorialContentStepDescription: "Aquí puedes escribir una breve descripción o nota sobre lo que sucede en este paso.",
                shareUrl: "Compartir URL", comboLoadedFromUrl: "¡Combo cargado desde la URL!", comboLoadFromUrlError: "Error al cargar combo desde la URL.",
                ctxEditCustomCard: "Editar Carta Personalizada",
                undoFromHere: "Deshacer todo desde aquí", lockStep: "Bloquear Paso", unlockStep: "Desbloquear Paso", undoFromHereConfirmTitle: "¿Borrar Pasos?", undoFromHereConfirmMessage: "¿Seguro que quieres borrar el Paso {stepNumber} y todos los siguientes? Esta acción no se puede deshacer.",
                or: "O",
                step: "Paso",
                autosaveRestore: "Se encontró un combo autoguardado. ¿Restaurar?",
                restore: "Restaurar",
                dismiss: "Descartar",
                emptyPoolTitle: "Tu Pool está vacío",
                emptyPoolMessage: "Usa la búsqueda para añadir cartas a tu combo.",
                emptyHandTitle: "Mano Inicial Vacía",
                emptyHandMessage: "Arrastra cartas desde tu Pool aquí.",
                emptyBoardTitle: "Campo Final Vacío",
                emptyBoardMessage: "Arrastra cartas desde tu Pool aquí.",
                toastRemoved: "Carta eliminada.",
                addGroup: "Añadir Grupo",
                groupTitlePlaceholder: "Título del Grupo",
                comboStatsTitle: "Estadísticas del Combo", statsCardTypes: "Distribución de Tipos", statsAttributes: "Distribución de Atributos", monster: "Monstruos", spell: "Magias", trap: "Trampas",
                exportTitleRequired: "Por favor, introduce un título para el combo antes de exportar.",
                saveOnlineTooltip: "Guardar en la Nube (Ctrl+S)", saveLocalTooltip: "Guardar Localmente (Ctrl+S)",
                loggedInAs: "Conectado como:", connecting: "Conectando para guardado en la nube...",
                publicCombosTitle: "Combos de la Comunidad", author: "Autor",
            },
            en: {
                 mainTitle: "Yu-Gi-Oh! Combo maker", mainSubtitle: "Create, visualize, and share your card combos.", undo: "Undo", redo: "Redo", exportPng: "Export as PNG", clearAll: "Clear All", addCardsTitle: "Add Cards", searchPlaceholder: "Search by name...", loading: "Searching for cards...", noCardsFound: "No cards found with these criteria or they have already been added.", searchError: "Error searching for cards.", comboPiecesTitle: "Combo Pieces", comboPiecesPlaceholder: "Search and add cards to start your combo.", comboTitlePlaceholder: "Title of the combo", startingHandTitle: "Starting Hand", startingHandPlaceholder: "Drag cards here to define your starting hand.", comboStepsTitle: "Combo Steps", addStep: "Add Step", addNote: "Add Note", comboStepsPlaceholder: "Drag a card or add a new step.", finalBoardTitle: "Final Board", addCard: "Add Card", finalBoardPlaceholder: "Build your final board here.", cardType: "Type", cardRace: "Race", clearConfirmTitle: "Clear Combo Guide?", clearConfirmMessage: "Are you sure you want to delete all cards and steps? This action cannot be undone.", confirm: "Confirm", cancel: "Cancel", cardSelectorSearch: "Search card...", cardSelectorNoMatch: "No matching cards.", pngPreviewTitle: "PNG Preview", download: "Download", generatingPng: "Generating PNG...", exportError: "Error exporting to PNG.", loadError: "Could not load saved combo.", ctxAddToHand: "Add to Starting Hand", ctxAddStep: "Add to Step", ctxAddFinalBoard: "Add to Final Board", ctxViewCard: "View Card", ctxDuplicateCard: "Duplicate Card", ctxRemoveFromPool: "Remove from Pieces", stepAffectedCards: "Affected Cards:", stepDescribeAction: "Describe the action...", finalBoardDisruption: "Disruption", untitledCombo: "Untitled Combo", cardAlreadyAdded: "Card is already in your pieces.", cardAlreadyInPool: "Card already in pool", exportOptions: "Export Options", include: "Include", notesTitle: "Notes & Strategy", notesPlaceholder: "Write your notes, choke points, etc. here...", exportOptionsTitle: "Export Options", confirmAndExport: "Confirm & Export", addToken: "Add Token", tokenSearchError: "Error fetching a random token.", filterBy: "Filter by:", filterArchetype: "Archetype", filterAttribute: "Attribute", filterLevel: "Level/Rank", filterType: "Card Type", clearFilters: "Clear Filters", all: "All", cardSize: "Card Size", show: "Add", hide: "Hide", saveAs: "Save", loadCombo: "Load Combo", share: "Share", saveComboTitle: "Save Combo", comboName: "Combo Name", save: "Save", loadComboTitle: "Load Combo", noCombosSaved: "No saved combos.", delete: "Delete", deleteConfirmMessage: "Are you sure you want to delete the combo '{comboName}'?", linkCopied: "Link copied to clipboard!", createCustomCard: "Create Custom Card", customCardTitle: "Create Custom Card", uploadImage: "Upload Image", cardName: "Card Name", cardDescription: "Description", attack: "Attack", defense: "Defense", create: "Create", preview: "Preview", showPreview: "Show Preview",
                apiCheck: "Verifying API connection...", apiCheckSuccess: "Connection successful!", apiCheckFail: "Could not connect to the API. Some features may be limited.",
                exportLayout: "Layout", exportLayoutGrid: "Grid", exportLayoutLines: "Lines", exportLayoutSingleColumn: "1-Column", exportQuality: "Image Quality", qualityLow: "Low", qualityMedium: "Medium", qualityHigh: "High",
                fetchingImages: "Fetching images...",
                templates: "Templates", loadTemplate: "Load Template", templateConfirm: "This will replace your current combo. Continue?", loadingTemplate: "Loading template...",
                cardNotes: "Card Notes", saveNotes: "Save Notes",
                nextPage: "Next", prevPage: "Previous", page: "Page",
                navigation: "Navigation",
                helpDisruption: "A 'disruption' is any action you can take during your opponent's turn to interrupt their strategy (e.g., negate an effect, destroy a card).",
                helpStartingHand: "The cards you begin the combo with. They represent your opening hand or cards available on the field at the start.",
                stepBreadcrumb: "Step {current} of {total}", stepLabel: "Step", actionsMenu: "Actions",
                cardZone: "Zone", location: "Location", selectZone: "Select Zone",
                recentChanges: "Recent Changes", estimatedTime: "Estimated combo time: ~{time}s", background: "Background", cardPoolTitle: "Card Pool",
                toggleConnector: "Toggle Connector", actionOther: "Other", stepAddTargetCard: "Add target card",
                addCardsToPoolFirst: "First, add cards to your 'Card Pool' to start building the combo.", otherComboPieces: "Other Combo Pieces",
                addStartingGroup: "Add group (OR)", addInitialHandGroup: "Add Starting Hand", addAlternateHand: "Add Alternate Hand",
                notificationAdded: "Added!",
                tutorialNext: "Next", tutorialSkip: "Skip", tutorialFinish: "Finish",
                tutorialTitleSearch: "Search Panel", tutorialContentSearch: "Welcome! Here you can search for any Yu-Gi-Oh! card to add to your combo. Use the filters to refine your search.",
                tutorialTitlePopularCards: "Popular Cards Carousel", tutorialContentPopularCards: "Here's a selection of popular cards for quick access. You can navigate with the arrows and click the title to hide/show the carousel.",
                tutorialTitlePool: "Card Pool", tutorialContentPool: "Cards you add from the search appear here. This is your 'inventory' of available cards to build the combo.",
                tutorialTitleHand: "Starting Hand", tutorialContentHand: "Drag cards from your 'Pool' here to define your starting hand. You can add alternate hands for different scenarios.",
                tutorialTitleSteps: "Combo Steps", tutorialContentSteps: "This is where the magic happens. Drag a card here to create the first step of your combo and describe the action.",
                tutorialTitleFinalBoard: "Final Board", tutorialContentFinalBoard: "This is where you build the board you leave at the end of your combo. Mark cards that serve as 'disruptions' for the opponent's turn.",
                tutorialTitleNotes: "Notes Section", tutorialContentNotes: "Use this space for additional notes, strategies, or choke points of the combo.",
                tutorialTitleActions: "Save & Export", tutorialContentActions: "Use these buttons to save your combo locally, share it with a link, or export it as an image for social media.",
                tutorialTitleStepActionSelect: "Select Action", tutorialContentStepActionSelect: "Use this menu to choose the main action for the step (Summon, Activate, etc.).",
                tutorialTitleStepVulnerability: "Mark Vulnerability", tutorialContentStepVulnerability: "Click this button ⚠️ to mark if this step is vulnerable to an opponent's interruption, like a 'handtrap'.",
                tutorialTitleStepAffectedCards: "Affected Cards", tutorialContentStepAffectedCards: "Use this button [+] to add other cards that are targeted or part of the action, like Fusion or Synchro materials.",
                tutorialTitleStepDescription: "Describe Action", tutorialContentStepDescription: "Here you can write a short description or note about what happens in this step.",
                shareUrl: "Share URL", comboLoadedFromUrl: "Combo loaded from URL!", comboLoadFromUrlError: "Error loading combo from URL.",
                ctxEditCustomCard: "Edit Custom Card",
                undoFromHere: "Undo all from here", lockStep: "Lock Step", unlockStep: "Unlock Step", undoFromHereConfirmTitle: "Delete Steps?", undoFromHereConfirmMessage: "Are you sure you want to delete Step {stepNumber} and all subsequent steps? This action cannot be undone.",
                or: "OR",
                step: "Step",
                autosaveRestore: "Autosaved combo found. Restore?",
                restore: "Restore",
                dismiss: "Dismiss",
                emptyPoolTitle: "Your Pool is empty",
                emptyPoolMessage: "Use the search to add cards to your combo.",
                emptyHandTitle: "Empty Starting Hand",
                emptyHandMessage: "Drag cards from your Pool here.",
                emptyBoardTitle: "Empty Final Board",
                emptyBoardMessage: "Drag cards from your Pool here.",
                toastRemoved: "Card removed.",
                addGroup: "Add Group",
                groupTitlePlaceholder: "Group Title",
                comboStatsTitle: "Combo Statistics", statsCardTypes: "Card Type Distribution", statsAttributes: "Attribute Distribution", monster: "Monsters", spell: "Spells", trap: "Traps",
                exportTitleRequired: "Please enter a title for the combo before exporting.",
                saveOnlineTooltip: "Save to Cloud (Ctrl+S)", saveLocalTooltip: "Save Locally (Ctrl+S)",
                loggedInAs: "Logged in as:", connecting: "Connecting for cloud save...",
                publicCombosTitle: "Community Combos", author: "Author",
            },
        };
        
        const YGOPRODECK_API_BASE_URL = 'https://yugoh-proxy.vercel.app/api/cardinfo';
        const CARD_TYPES = ["Effect Monster", "Flip Effect Monster", "Fusion Monster", "Link Monster", "Normal Monster", "Pendulum Effect Monster", "Ritual Effect Monster", "Spell Card", "Synchro Monster", "Token", "Trap Card", "Tuner Monster", "Union Effect Monster", "Xyz Monster"];
        const ATTRIBUTES = ["DARK", "DIVINE", "EARTH", "FIRE", "LIGHT", "WATER", "WIND"];
        const LEVELS = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
        const CARDS_PER_PAGE = 18;
        const YGO_ZONES = ["Extra Monster 1", "Extra Monster 2", "Main Monster 1", "Main Monster 2", "Main Monster 3", "Main Monster 4", "Main Monster 5", "Spell/Trap 1", "Spell/Trap 2", "Spell/Trap 3", "Spell/Trap 4", "Spell/Trap 5", "Field Zone", "Graveyard", "Banish Pile"];
        const ZONE_ABBREVIATIONS = {
            "Extra Monster 1": "EMZ1", "Extra Monster 2": "EMZ2",
            "Main Monster 1": "MMZ1", "Main Monster 2": "MMZ2", "Main Monster 3": "MMZ3", "Main Monster 4": "MMZ4", "Main Monster 5": "MMZ5",
            "Spell/Trap 1": "S/T1", "Spell/Trap 2": "S/T2", "Spell/Trap 3": "S/T3", "Spell/Trap 4": "S/T4", "Spell/Trap 5": "S/T5",
            "Field Zone": "Field", "Graveyard": "GY", "Banish Pile": "Banish"
        };
        const LOCAL_STORAGE_PREFIX = 'ygo_combo_';
        const AUTO_SAVE_KEY = 'ygo_combo_autosave';
        const debounce = (func, delay) => { let timeout; return (...args) => { clearTimeout(timeout); timeout = setTimeout(() => func.apply(this, args), delay); }; };
        const generateId = () => crypto.randomUUID();
        const sanitizeHTML = (str) => window.DOMPurify ? window.DOMPurify.sanitize(str, {ALLOWED_TAGS: ['b', 'i', 'u', 'br', 'ul', 'ol', 'li', 'p', 'div', 'span'], ALLOWED_ATTR: ['style']}) : str;
        const createComboCardInstance = (apiCard, imageProxy) => {
            if (!apiCard) return null;
            if (apiCard.isCustom) {
                return { ...apiCard, instanceId: generateId(), notes: '' };
            }
            const getImageUrl = (url) => {
                if (!url) return 'https://placehold.co/100x150/1e293b/a78bfa?text=No+Img';
                const bareUrl = url.replace(/^https?:\/\//, '');
                return `${imageProxy}${bareUrl}`;
            };
            const imageUrl = getImageUrl(apiCard.card_images?.[0]?.image_url);
            const imageUrlSmall = getImageUrl(apiCard.card_images?.[0]?.image_url_small);
            const imageUrlCropped = getImageUrl(apiCard.card_images?.[0]?.image_url_cropped);
            return {
                instanceId: generateId(), ygoprodeck_id: apiCard.id, name: apiCard.name, type: apiCard.type, desc: apiCard.desc,
                atk: apiCard.atk, def: apiCard.def, level: apiCard.level, race: apiCard.race, attribute: apiCard.attribute, scale: apiCard.scale, linkval: apiCard.linkval, linkmarkers: apiCard.linkmarkers,
                card_prices: apiCard.card_prices,
                image_url: imageUrl, image_url_small: imageUrlSmall, image_url_cropped: imageUrlCropped, isCustom: false, notes: '',
            };
        };
        const YGO_ACTIONS = [ { name: "Normal Summon", emoji: "⬆️" }, { name: "Special Summon", emoji: "⭐" }, { name: "Set", emoji: "⬇️" }, { name: "Activate Spell/Trap", emoji: "🌀" }, { name: "Activate Effect", emoji: "⚡" }, { name: "Attack", emoji: "⚔️" }, { name: "Send to GY", emoji: "🪦" }, { name: "Discard", emoji: "👋" }, { name: "Banish", emoji: "🌌" }, { name: "Add to Hand", emoji: "✋" }, { name: "Search", emoji: "🔍" }, { name: "Fusion Summon", emoji: "⚛️" }, { name: "Synchro Summon", emoji: "🟢" }, { name: "Xyz Summon", emoji: "💫" }, { name: "Pendulum Summon", emoji: "⚖️" }, { name: "Link Summon", emoji: "🔻" }, { name: "Other", emoji: "..." } ];
        
        const Spinner = () => <div className="spinner"></div>;

        const useHistoryState = (initialState) => {
            const [history, setHistory] = useState([{ state: initialState, description: "Initial State" }]);
            const [currentIndex, setCurrentIndex] = useState(0);
            const state = history[currentIndex].state;
            const canUndo = currentIndex > 0;
            const canRedo = currentIndex < history.length - 1;
            const setState = (newState, description) => { const newHistory = history.slice(0, currentIndex + 1); newHistory.push({ state: newState, description }); setHistory(newHistory); setCurrentIndex(newHistory.length - 1); };
            const loadState = (loadedState, description = "Loaded State") => { const newState = { state: loadedState, description }; setHistory([newState]); setCurrentIndex(0); };
            const undo = () => { if (canUndo) setCurrentIndex(currentIndex - 1); };
            const redo = () => { if (canRedo) setCurrentIndex(currentIndex + 1); };
            return { state, setState, loadState, undo, redo, canUndo, canRedo };
        };

        const CardDisplay = memo(({ card, onClick, onRemove, onEdit, draggable = false, onDragStart, onDragEnd, onTouchStart, size = 'normal', isAdded = false, onContextMenu, t, isHighlighted, quantity, onQuantityChange, useCropped = false, isNew = false, onMouseEnter, onMouseLeave, onMouseMove, children }) => {
            if (!card) return null;
            const [isImageLoaded, setIsImageLoaded] = useState(false);
            const sizeClasses = { large: 'w-36', medium: 'w-32', normal: 'w-28', small: 'w-24', tiny: 'w-16' };
            const cardRef = useRef(null);
            
            useEffect(() => {
                if (isNew && cardRef.current) {
                    cardRef.current.classList.add('card-enter');
                    requestAnimationFrame(() => {
                        cardRef.current.classList.add('card-enter-active');
                    });
                }
            }, [isNew]);

            const clickHandler = onClick ? (e) => { e.stopPropagation(); onClick(card, e); } : null;
            const contextMenuHandler = onContextMenu ? (e) => { e.preventDefault(); e.stopPropagation(); onContextMenu(card, e); } : null;
            const removeHandler = onRemove ? (e) => { e.stopPropagation(); onRemove(); } : null;
            const imageUrl = useCropped ? card.image_url_cropped : (card.image_url_small || card.image_url);

            return (
                <div 
                    ref={cardRef}
                    draggable={draggable} onDragStart={onDragStart} onDragEnd={onDragEnd} onTouchStart={onTouchStart}
                    onContextMenu={contextMenuHandler} data-instance-id={card.instanceId} 
                    className={`card-display relative group flex flex-col items-center rounded-lg shadow-md p-1 border border-[var(--color-border)] ${sizeClasses[size]} ${isAdded ? 'opacity-50' : 'cursor-pointer hover:opacity-90 hover:scale-105'} ${isHighlighted ? 'card-highlight' : ''} bg-[var(--color-surface)]`}
                    onClick={clickHandler}
                    onMouseEnter={(e) => onMouseEnter && onMouseEnter(card, e)}
                    onMouseLeave={(e) => onMouseLeave && onMouseLeave(e)}
                    onMouseMove={(e) => onMouseMove && onMouseMove(e)}
                >
                    {children}
                    <div className="absolute top-0 right-0 z-20 flex">
                        {onEdit && card.isCustom && (<button onClick={(e) => { e.stopPropagation(); onEdit(card); }} className="btn w-6 h-6 bg-blue-600 text-white rounded-full flex items-center justify-center text-xs font-bold hover:bg-blue-700 -mt-2 -mr-1" aria-label="Editar" data-tooltip="Editar"><i className="fas fa-pencil-alt"></i></button>)}
                        {onRemove && (<button onClick={removeHandler} className="btn w-6 h-6 bg-red-600 text-white rounded-full flex items-center justify-center text-xs font-bold hover:bg-red-700 -mt-2 -mr-2" aria-label="Eliminar" data-tooltip="Eliminar"><i className="fas fa-times"></i></button>)}
                    </div>
                    {quantity > 1 && (<div className="absolute top-1 left-1 bg-black/50 text-white text-xs font-bold px-2 py-0.5 rounded-full z-10">x{quantity}</div>)}
                    <div className="relative w-full" style={{ aspectRatio: useCropped ? '1' : '0.686' }}>
                        {!isImageLoaded && <div className="absolute inset-0 card-skeleton"></div>}
                        <img 
                            src={imageUrl} 
                            alt={card.name} 
                            className={`w-full object-cover rounded-md shadow-lg transition-opacity duration-300 ${isImageLoaded ? 'opacity-100' : 'opacity-0'}`}
                            onLoad={() => setIsImageLoaded(true)}
                            crossOrigin="anonymous" 
                            onError={(e) => { e.target.onerror = null; e.target.src = 'https://placehold.co/100x150/1e293b/a78bfa?text=Error'; setIsImageLoaded(true); }} 
                        />
                    </div>
                    {(!useCropped && (size === 'normal' || size === 'medium' || size === 'large')) && (<p className="w-full text-xs font-medium text-center truncate mt-1 px-1">{card.name}</p>)}
                    {onQuantityChange && (<div className="absolute -bottom-2 left-1/2 -translate-x-1/2 flex items-center bg-black/50 rounded-full px-1 opacity-0 group-hover:opacity-100 transition-opacity"><button onClick={(e) => {e.stopPropagation(); onQuantityChange(card.instanceId, -1)}} className="btn text-white font-bold text-lg leading-none px-2">-</button><button onClick={(e) => {e.stopPropagation(); onQuantityChange(card.instanceId, 1)}} className="btn text-white font-bold text-lg leading-none px-2">+</button></div>)}
                </div>
            );
        });

        const CardZoomModal = ({ card, onClose, t, onSaveNotes }) => {
            const [isClosing, setIsClosing] = useState(false);
            
            useEffect(() => {
                if (!card) setIsClosing(false);
            }, [card]);

            if (!card) return null;

            const handleClose = () => {
                setIsClosing(true);
                setTimeout(() => {
                    onClose();
                }, 300); // Match animation duration
            };

            const displayImageSrc = card?.image_url || 'https://placehold.co/300x450/1e293b/a78bfa?text=No+Image';
            
            return (
                <div className={`fixed inset-0 bg-black bg-opacity-80 backdrop-blur-sm flex items-center justify-center z-50 p-4 ${isClosing ? 'modal-exit' : 'modal-enter'}`} onClick={handleClose}>
                    <div className="modal-content bg-[var(--color-surface)] border border-[var(--color-border)] rounded-lg shadow-xl p-6 max-w-4xl w-full relative" onClick={e => e.stopPropagation()}>
                        <button onClick={handleClose} className="absolute top-3 right-3 text-gray-400 hover:text-white text-2xl font-bold">×</button>
                        <div className="flex flex-col md:flex-row gap-6">
                            <div className="flex-shrink-0 flex justify-center"><img src={displayImageSrc} alt={card?.name} className="w-full max-w-[300px] h-auto rounded-lg shadow-lg" crossOrigin="anonymous" onError={(e) => { e.target.onerror = null; e.target.src = 'https://placehold.co/300x450/1e293b/a78bfa?text=Error'; }} /></div>
                            <div className="flex-grow text-[var(--color-text)] flex flex-col">
                                <h2 className="text-3xl font-bold mb-2 text-[var(--color-secondary)]">{card?.name}</h2>
                                <p className="text-lg mb-1"><span className="font-semibold text-[var(--color-text-muted)]">{t('cardType')}:</span> {card?.type}</p>
                                {card?.race && <p className="text-lg mb-1"><span className="font-semibold text-[var(--color-text-muted)]">{t('cardRace')}:</span> {card.race}</p>}
                                <p className="text-md mt-4 whitespace-pre-wrap bg-[var(--color-background)] p-3 rounded-md border border-[var(--color-border)] max-h-48 overflow-y-auto">{card?.desc}</p>
                                {onSaveNotes && (<div className="mt-4 flex-grow flex flex-col"><label className="text-lg font-semibold mb-2 text-[var(--color-text)]">{t('cardNotes')}</label><textarea value={card.notes || ''} onChange={e => onSaveNotes(card.instanceId, e.target.value)} className="w-full flex-grow p-2 bg-[var(--color-background)] border border-[var(--color-border)] rounded-md text-sm" rows="4"></textarea></div>)}
                            </div>
                        </div>
                    </div>
                </div>
            );
        };
        
        const CardHoverPreview = ({ card }) => {
            const [show, setShow] = useState(false);
            const timerRef = useRef(null);
        
            useEffect(() => {
                clearTimeout(timerRef.current);
                if (card) {
                    timerRef.current = setTimeout(() => setShow(true), 250); // Delay before showing
                } else {
                    setShow(false);
                }
                return () => clearTimeout(timerRef.current);
            }, [card]);
        
            if (!card || !show) return null;
        
            const container = document.getElementById('card-hover-preview-container');
            if (!container) return null;
        
            const mx = window.__YGO_MOUSE__?.x || 0;
            const my = window.__YGO_MOUSE__?.y || 0;
        
            const pad = 16, boxW = 320, boxH = 280;
            let left = mx + 24;
            let top = my - boxH / 2;
        
            if (left + boxW > window.innerWidth - pad) {
                left = mx - boxW - 24;
            }
            top = Math.max(pad, Math.min(top, window.innerHeight - boxH - pad));
        
            const style = { position: 'fixed', top: `${top}px`, left: `${left}px` };
        
            const previewContent = (
                <div id="card-hover-preview" style={style} className={card ? 'visible' : ''}>
                    <div className="flex gap-4">
                        <div className="w-28 flex-shrink-0">
                            <img src={card.image_url_small || card.image_url} alt={card.name} className="w-full h-auto rounded-md" crossOrigin="anonymous" onError={(e) => { e.target.onerror = null; e.target.src = 'https://placehold.co/100x150/1e293b/a78bfa?text=Error'; }} />
                        </div>
                        <div className="flex-grow min-w-0">
                            <h3 className="text-lg font-bold text-violet-300 truncate">{card.name}</h3>
                            <p className="text-sm text-slate-400 mb-2">{card.type}</p>
                            <p className="text-xs text-slate-200 max-h-36 overflow-y-auto">{card.desc}</p>
                        </div>
                    </div>
                </div>
            );
            return createPortal(previewContent, container);
        };

        const ConfirmationModal = ({ show, title, message, onConfirm, onCancel, t }) => { 
            const [isClosing, setIsClosing] = useState(false);
            
            useEffect(() => {
                if (!show) setIsClosing(false);
            }, [show]);

            if (!show) return null;

            const handleConfirm = () => {
                setIsClosing(true);
                setTimeout(() => onConfirm(), 300);
            };
            const handleCancel = () => {
                setIsClosing(true);
                setTimeout(() => onCancel(), 300);
            };

            return (
                <div className={`fixed inset-0 bg-black bg-opacity-75 backdrop-blur-sm flex items-center justify-center z-50 p-4 ${isClosing ? 'modal-exit' : 'modal-enter'}`}>
                    <div className="modal-content bg-[var(--color-surface)] border border-[var(--color-border)] rounded-lg shadow-xl p-8 max-w-sm w-full relative text-center">
                        <h3 className="text-xl font-bold mb-4 text-[var(--color-danger)]">{title}</h3>
                        <p className="text-[var(--color-text)] mb-6">{message}</p>
                        <div className="flex justify-center gap-4">
                            <button onClick={handleConfirm} className="btn px-5 py-2 bg-red-600 text-white font-semibold rounded-lg hover:bg-red-700 transition-colors shadow-md">{t('confirm')}</button>
                            <button onClick={handleCancel} className="btn px-5 py-2 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-700 transition-colors shadow-md">{t('cancel')}</button>
                        </div>
                    </div>
                </div>
            ); 
        };
        
        const ZonePickerModal = ({ show, onClose, onSelect, t }) => {
            if (!show) return null;

            const handleSelect = (zone) => {
                onSelect(zone);
                onClose();
            };

            const zones = [
                { name: "Extra Monster 1", gridClass: "grid-pos-emz1" },
                { name: "Extra Monster 2", gridClass: "grid-pos-emz2" },
                { name: "Field Zone", gridClass: "grid-pos-fz" },
                { name: "Main Monster 1", gridClass: "grid-pos-mmz1" },
                { name: "Main Monster 2", gridClass: "grid-pos-mmz2" },
                { name: "Main Monster 3", gridClass: "grid-pos-mmz3" },
                { name: "Main Monster 4", gridClass: "grid-pos-mmz4" },
                { name: "Main Monster 5", gridClass: "grid-pos-mmz5" },
                { name: "Graveyard", gridClass: "grid-pos-gy" },
                { name: "Spell/Trap 1", gridClass: "grid-pos-stz1" },
                { name: "Spell/Trap 2", gridClass: "grid-pos-stz2" },
                { name: "Spell/Trap 3", gridClass: "grid-pos-stz3" },
                { name: "Spell/Trap 4", gridClass: "grid-pos-stz4" },
                { name: "Spell/Trap 5", gridClass: "grid-pos-stz5" },
                { name: "Banish Pile", gridClass: "grid-pos-bp" },
            ];

            return (
                <div className="fixed inset-0 bg-black bg-opacity-75 backdrop-blur-sm flex items-center justify-center z-50 p-4 modal-enter" onClick={onClose}>
                    <div className="modal-content bg-slate-900 border border-slate-700 rounded-lg shadow-xl p-6 max-w-lg w-full relative" onClick={e => e.stopPropagation()}>
                        <h3 className="text-xl font-bold mb-6 text-violet-300 text-center">{t('selectZone')}</h3>
                        <div className="ygo-field-grid">
                            {zones.map(zone => (
                                <button 
                                    key={zone.name} 
                                    className={`ygo-field-zone ${zone.gridClass}`}
                                    onClick={() => handleSelect(zone.name)}
                                >
                                    {ZONE_ABBREVIATIONS[zone.name] || zone.name}
                                </button>
                            ))}
                        </div>
                         <div className="flex justify-end mt-6">
                            <button onClick={onClose} className="px-5 py-2 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-700">{t('cancel')}</button>
                        </div>
                    </div>
                </div>
            );
        };

        const CardSelector = ({ cardPool, onCardSelected, buttonText, displayAs = 'button', t, wrapperClassName = '', onMouseEnter, onMouseLeave, onMouseMove, preferredDirection = 'down' }) => {
            const [isOpen, setIsOpen] = useState(false);
            const inputRef = useRef(null);
            const [filter, setFilter] = useState('');
            const containerRef = useRef(null);
            const [isMobile, setIsMobile] = useState(window.innerWidth <= 1024);
            const [positionClasses, setPositionClasses] = useState('');

            useEffect(() => {
                const checkMobile = () => setIsMobile(window.innerWidth <= 1024);
                window.addEventListener('resize', checkMobile);
                return () => window.removeEventListener('resize', checkMobile);
            }, []);

            useEffect(() => {
                const handleClickOutside = (event) => {
                    if (containerRef.current && !containerRef.current.contains(event.target)) {
                        setIsOpen(false);
                    }
                };
                document.addEventListener('mousedown', handleClickOutside);
                return () => document.removeEventListener('mousedown', handleClickOutside);
            }, []);

            useEffect(() => {
                if (isOpen && inputRef.current) {
                    setTimeout(() => {
                        inputRef.current?.focus();
                    }, 0);
                }
            }, [isOpen, filter]);
            
            useLayoutEffect(() => {
                if (isOpen && containerRef.current) {
                    const buttonRect = containerRef.current.getBoundingClientRect();
                    const menuWidth = 300; 
                    const menuHeight = 320; 

                    let classes = 'top-full mt-2 left-0'; 

                    if (preferredDirection === 'side') {
                        if (buttonRect.right + menuWidth > window.innerWidth) {
                            classes = 'top-0 right-full mr-2';
                        } else {
                            classes = 'top-0 left-full ml-2';
                        }
                    } else if (preferredDirection === 'up') {
                        if (buttonRect.top - menuHeight < 0) {
                            classes = 'top-full mt-2 left-0';
                        } else {
                            classes = 'bottom-full mb-2 left-0';
                        }
                    }
                    setPositionClasses(classes);
                }
            }, [isOpen, preferredDirection]);


            const filteredPool = cardPool.filter(card => card.name.toLowerCase().includes(filter.toLowerCase()));
            const buttonClasses = { 'button': "w-full px-4 py-2 bg-violet-600 text-white font-semibold rounded-lg hover:bg-violet-700 transition-colors shadow-md disabled:bg-violet-800 disabled:cursor-not-allowed", 'small-button': "p-2 bg-violet-600 text-white font-bold rounded-full hover:bg-violet-700 transition-colors shadow-md disabled:bg-violet-800 disabled:cursor-not-allowed flex items-center justify-center", 'card-placeholder': "w-28 h-44 flex items-center justify-center border-2 border-dashed border-slate-600 rounded-lg text-slate-400 hover:bg-slate-700/50 hover:text-white transition-colors" };
            const buttonContent = { 'button': buttonText || t('addStep'), 'small-button': <i className="fas fa-plus"></i>, 'card-placeholder': <i className="fas fa-plus"></i> };
            
            const handleSelect = (card) => {
                onCardSelected(card);
                setIsOpen(false);
                setFilter('');
            };

            const DesktopMenu = () => {
                const isTwoColumn = filteredPool.length > 7;
                const menuWidthClass = isTwoColumn ? 'w-[30rem]' : 'w-72';
                return (
                     <div className={`absolute ${positionClasses} ${menuWidthClass} bg-slate-800 rounded-md shadow-lg border border-slate-700 z-50 flex flex-col max-h-80`}>
                        <input
                            type="text"
                            key="card-selector-desktop-input"
                            placeholder={t('cardSelectorSearch')}
                            value={filter}
                            onChange={e => { setFilter(e.target.value); }}
                            onKeyDown={e => { if (e.key === 'Enter' && filteredPool.length > 0) { e.preventDefault(); handleSelect(filteredPool[0]); } }}
                            ref={inputRef}
                            autoFocus
                            className="p-2 bg-slate-900 text-white placeholder-gray-400 focus:ring-0 outline-none sticky top-0"
                        />
                        <div
                            onMouseDown={() => handleSelect({ isNote: true })}
                            className="flex items-center p-2 hover:bg-slate-700 cursor-pointer text-sm text-amber-300 font-semibold border-b border-slate-700"
                        >
                            <i className="fas fa-sticky-note w-10 text-center mr-2"></i>
                            <span>{t('addNote')}</span>
                        </div>
                        <div className={`overflow-y-auto ${isTwoColumn ? 'grid grid-cols-2 gap-1 p-1' : ''}`}> 
                            {filteredPool.length > 0 ? filteredPool.map(card => (
                                <div
                                    key={card.instanceId}
                                    onMouseDown={() => handleSelect(card)}
                                    className={`flex items-center p-2 hover:bg-slate-700 cursor-pointer text-sm ${isTwoColumn ? 'w-full' : ''}`}
                                    onMouseEnter={(e) => onMouseEnter && onMouseEnter(card, e)}
                                    onMouseLeave={(e) => onMouseLeave && onMouseLeave(e)}
                                    onMouseMove={(e) => onMouseMove && onMouseMove(e)}
                                >
                                    <img src={card.image_url_small || card.image_url} alt={card.name} className="w-10 h-14 object-cover rounded-sm mr-2" crossOrigin="anonymous" />
                                    <span className="truncate">{card.name}</span>
                                </div>
                            )) : <div className="p-2 text-gray-400">{t('cardSelectorNoMatch')}</div>}
                        </div>
                    </div>
                );
            };

            const MobileOverlay = () => (
                <div className="fixed inset-0 bg-black/80 backdrop-blur-sm z-[100] flex flex-col p-4">
                    <div className="flex-shrink-0 mb-4 flex items-center gap-4">
                        <input
                            type="text"
                            key="card-selector-mobile-input"
                            placeholder={t('cardSelectorSearch')}
                            value={filter}
                            onChange={e => { setFilter(e.target.value); }}
                            ref={inputRef}
                            autoFocus
                            onKeyDown={e => { if (e.key === 'Enter' && filteredPool.length > 0) { e.preventDefault(); handleSelect(filteredPool[0]); } }}
                            className="w-full p-3 bg-slate-700 border border-slate-600 rounded-lg focus:ring-2 focus:ring-violet-500 focus:outline-none"
                        />
                        <button onClick={() => setIsOpen(false)} className="p-3 bg-red-600 text-white rounded-full"><i className="fas fa-times"></i></button>
                    </div>
                    <div className="flex-shrink-0 mb-2">
                        <button
                            onClick={() => handleSelect({ isNote: true })}
                            className="w-full p-3 bg-amber-600 text-white font-semibold rounded-lg hover:bg-amber-700 transition-colors"
                        >
                            <i className="fas fa-sticky-note mr-2"></i>
                            {t('addNote')}
                        </button>
                    </div>
                    <div className="flex-grow overflow-y-auto bg-slate-900/50 rounded-lg p-2">
                        <div className="grid grid-cols-[repeat(auto-fill,minmax(6rem,1fr))] gap-2">
                            {filteredPool.length > 0 ? filteredPool.map(card => (
                                <CardDisplay key={card.instanceId} card={card} size="small" onClick={() => handleSelect(card)} />
                            )) : <p className="text-slate-400 p-4 text-center w-full col-span-full">{t('cardSelectorNoMatch')}</p>}
                        </div>
                    </div>
                </div>
            );

            return (
                <div ref={containerRef} className={`relative ${wrapperClassName}`}>
                    <button onClick={() => setIsOpen(prev => !prev)} className={buttonClasses[displayAs]} disabled={cardPool.length === 0}>
                        {buttonContent[displayAs]}
                    </button>
                    {isOpen && (isMobile ? <MobileOverlay /> : <DesktopMenu />)}
                </div>
            );
        };

        const PngPreviewModal = ({ imageUrl, onDownload, onClose, t, onShare, comboTitle, shareUrl }) => {
            if (!imageUrl) return null;
            
            const twitterShareUrl = useMemo(() => {
                const text = encodeURIComponent(`Check out this Yu-Gi-Oh! combo I made: "${comboTitle || 'Awesome Combo'}"!`);
                const url = encodeURIComponent(shareUrl);
                return `https://twitter.com/intent/tweet?text=${text}&url=${url}`;
            }, [comboTitle, shareUrl]);

            const facebookShareUrl = useMemo(() => {
                const url = encodeURIComponent(shareUrl);
                return `https://www.facebook.com/sharer/sharer.php?u=${url}`;
            }, [shareUrl]);

            return (
                <div className="fixed inset-0 bg-black bg-opacity-80 backdrop-blur-sm flex items-center justify-center z-50 p-4" onClick={onClose}>
                    <div className="bg-slate-900 border border-slate-700 rounded-lg shadow-xl p-6 max-w-5xl w-full relative text-center" onClick={e => e.stopPropagation()}>
                        <h3 className="text-2xl font-bold mb-4 text-violet-400">{t('pngPreviewTitle')}</h3>
                        <div className="bg-slate-900/50 p-4 rounded-md max-h-[70vh] overflow-auto">
                           <img src={imageUrl} alt="Combo preview" className="max-w-full h-auto mx-auto shadow-2xl" />
                        </div>
                        <div className="flex justify-center flex-wrap gap-4 mt-6">
                            <button onClick={onDownload} className="btn px-5 py-2 bg-green-600 text-white font-semibold rounded-lg hover:bg-green-700 transition-colors shadow-md">{t('download')}</button>
                            <button onClick={onClose} className="btn px-5 py-2 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-700 transition-colors shadow-md">{t('cancel')}</button>
                        </div>
                    </div>
                </div>
            );
        };
        const ExportLayout = ({ comboTitle, startingHand, comboSteps, finalBoardCards, notes, findCard, t, exportOptions, imageMap }) => { 
            const nbsp = (str) => String(str || '').replace(/ /g, '\u00A0');
            const nbspHtml = (str) => String(str || '').replace(/ /g, '&nbsp;');

            const backgroundStyle = { backgroundColor: '#020617', backgroundImage: `radial-gradient(circle at 20% 30%, rgba(139, 92, 246, 0.15) 0%, transparent 40%), radial-gradient(circle at 80% 70%, rgba(167, 139, 250, 0.15) 0%, transparent 40%)`, position: 'relative', overflow: 'hidden' };
            const ExportCard = ({ card, size = 'normal', quantity, useCropped = false, children, location }) => { 
                if (!card) return null; 
                const src = imageMap[useCropped ? card.image_url_cropped : card.image_url_small] || (useCropped ? card.image_url_cropped : card.image_url_small); 
                const sizeClass = { large: 'w-40', medium: 'w-36', normal: 'w-32', small: 'w-24', tiny: 'w-16', micro: 'w-12' }[size]; 
                return ( 
                    <div className={`relative ${sizeClass} flex-shrink-0 flex flex-col items-center`}> 
                        {children} 
                        <img src={src} alt={card.name} className="w-full rounded-md shadow-lg border-2 border-slate-600" style={{ aspectRatio: useCropped ? '1' : '0.686' }}/> 
                        {quantity > 1 && <div className="absolute -top-2 -right-2 bg-slate-900 text-white text-sm font-bold w-6 h-6 flex items-center justify-center rounded-full border-2 border-slate-400">x{quantity}</div>} 
                        {location && <div className="mt-1 text-xs font-bold text-amber-300 bg-black/50 px-2 py-0.5 rounded-full">{nbsp(location)}</div>}
                    </div> 
                ); 
            }; 
            const stepsPerRow = exportOptions.stepsPerRow || 4;
            
            const renderStepRows = () => {
                const elements = [];
                let currentStepRow = [];

                const flushStepRow = () => {
                    if (currentStepRow.length > 0) {
                        elements.push(
                            <div key={`row-${elements.length}`} className="grid items-stretch gap-4" style={{gridTemplateColumns: `repeat(${stepsPerRow}, minmax(0, 1fr))`}}>
                                {currentStepRow}
                            </div>
                        );
                        currentStepRow = [];
                    }
                };
                
                const actualStepCounter = comboSteps.filter(s => s.type === 'step');

                comboSteps.forEach(step => {
                    if (step.type === 'group') {
                        flushStepRow();
                        elements.push(
                            <div key={step.id} className="col-span-full flex items-center gap-2 mt-4 mb-2">
                                <div className="h-px flex-grow bg-amber-700/50"></div>
                                <h4 className="font-bold text-amber-300 text-lg">{nbsp(step.title)}</h4>
                                <div className="h-px flex-grow bg-amber-700/50"></div>
                            </div>
                        );
                    } else {
                        let itemJsx = null;
                        if (step.type === 'note') {
                             itemJsx = (
                                <div key={step.id} className="bg-yellow-900/30 p-3 rounded-lg border border-yellow-700/50 flex flex-col items-start gap-2 text-left h-full">
                                    <div className="flex items-center gap-2 self-start">
                                        <i className="fas fa-sticky-note text-yellow-300"></i>
                                        <h3 className="font-semibold text-base text-yellow-300">{nbsp(t('addNote'))}</h3>
                                    </div>
                                    <p className="text-yellow-200 text-sm mt-2 flex-grow break-words whitespace-pre-wrap text-left w-full">{nbsp(step.text)}</p>
                                </div>
                            );
                        } else if (step.type === 'step') {
                            const mainCard = findCard(step.mainCardInstanceId);
                            const action = YGO_ACTIONS.find(a => a.name === step.actionType) || {};
                            const isVulnerable = step.vulnerability?.text || (step.vulnerability?.cards && step.vulnerability.cards.length > 0);
                            const stepNumber = actualStepCounter.findIndex(s => s.id === step.id) + 1;

                            itemJsx = (
                                <div key={step.id} className={`bg-slate-900/50 p-3 rounded-lg border ${isVulnerable ? 'border-red-500' : 'border-slate-700'} flex flex-col items-center gap-2 text-center h-full`}>
                                    <span className="font-bold text-lg text-slate-300">{nbsp(t('step'))} {stepNumber}</span>
                                    <h3 className="font-semibold text-base text-yellow-300 h-12 flex items-center justify-center">{action.emoji} {nbsp(step.actionType === 'Other' ? step.customActionText : step.actionType)}</h3>
                                    <div className="relative">
                                        <ExportCard card={mainCard} size="medium" location={step.location ? ZONE_ABBREVIATIONS[step.location] : null} />
                                        {step.vulnerability?.cards && step.vulnerability.cards.length > 0 && (
                                            <div className="absolute -right-3 -top-3 z-10 flex flex-col gap-1">
                                                {step.vulnerability.cards.map(vCard => (
                                                    <ExportCard key={vCard.instanceId} card={findCard(vCard.instanceId)} size="micro" useCropped={true}>
                                                        <span className="absolute top-0 right-0 text-lg z-10 -mt-1 -mr-1" style={{textShadow: '0 0 3px black'}}>⚠️</span>
                                                    </ExportCard>
                                                ))}
                                            </div>
                                        )}
                                    </div>
                                    <p className="text-slate-300 text-xs mt-2 uppercase flex-grow break-all min-h-[2.5rem]">{nbsp(step.actionDescription)}</p>
                                    {step.vulnerability?.text && <p className="text-red-400 text-xs font-bold mt-1">{nbsp(step.vulnerability.text)}</p>}
                                    {step.targetCards.length > 0 && (
                                        <div className="flex flex-wrap justify-center items-center gap-1 w-full mt-2 relative z-10">
                                            {step.targetCards.map(target => <ExportCard key={`target-${target.instanceId}`} card={findCard(target.instanceId)} size="tiny" quantity={target.quantity} />)}
                                        </div>
                                    )}
                                </div>
                            );
                        }

                        if (itemJsx) {
                            currentStepRow.push(itemJsx);
                            if (currentStepRow.length === stepsPerRow) {
                                flushStepRow();
                            }
                        }
                    }
                });

                flushStepRow();
                return elements;
            };

            return ( 
                <div className="p-8 text-white export-onewm" data-watermark={'YGOH-ComboMaker'} style={backgroundStyle}>
                    <div className="relative z-10">
                        <h1 className="text-5xl font-bold text-center text-violet-300 mb-8 font-yugioh">{nbsp(comboTitle || t('untitledCombo'))}</h1> 
                        <div className="flex flex-col gap-6"> 
                            {( (exportOptions.include.startingHand && startingHand.length > 0 && startingHand.some(g => g.length > 0)) || (exportOptions.include.notes && notes) ) && (
                                <div className="flex flex-row gap-6 items-stretch">
                                    {exportOptions.include.startingHand && startingHand.length > 0 && startingHand.some(g => g.length > 0) && (
                                        <div className="bg-slate-800/50 p-4 rounded-lg border border-slate-700 flex flex-col" style={{ width: (exportOptions.include.notes && notes) ? '33.33%' : '100%' }}>
                                            <h2 className="text-2xl font-semibold mb-4 text-violet-400 font-yugioh">{nbsp(t('startingHandTitle'))}</h2>
                                            <div className="flex-grow flex flex-row flex-wrap items-center justify-center gap-3">
                                                {startingHand.map((group, groupIndex) => (
                                                    <React.Fragment key={groupIndex}>
                                                        <div className="p-2 bg-slate-900/50 rounded-lg flex flex-wrap justify-center items-center gap-2 border border-dashed border-slate-600">
                                                            {group.map(item => <ExportCard key={`hand-${item.instanceId}`} card={findCard(item.instanceId)} size="small" quantity={item.quantity} />)}
                                                        </div>
                                                        {groupIndex < startingHand.length - 1 && <span className="font-bold text-violet-400 text-2xl">{nbsp(t('or'))}</span>}
                                                    </React.Fragment>
                                                ))}
                                            </div>
                                        </div>
                                    )}
                                    {exportOptions.include.notes && notes && (
                                        <div className="bg-slate-800/50 p-4 rounded-lg border border-slate-700 flex-grow min-w-0">
                                            <h2 className="text-2xl font-semibold mb-4 text-violet-400 font-yugioh">{nbsp(t('notesTitle'))}</h2>
                                            <div className="text-sm whitespace-pre-wrap break-words" style={{ direction: 'ltr', textAlign: 'left' }} dangerouslySetInnerHTML={{ __html: nbspHtml(notes) }} />
                                        </div>
                                    )}
                                </div>
                            )}
                            {exportOptions.include.comboSteps && comboSteps.length > 0 && (
                                <div className="bg-slate-800/50 p-4 rounded-lg border border-slate-700">
                                    <h2 className="text-2xl font-semibold mb-4 text-violet-400 font-yugioh">{nbsp(t('comboStepsTitle'))}</h2>
                                    <div className="space-y-4">
                                        {renderStepRows()}
                                    </div>
                                </div>
                            )}
                            {exportOptions.include.finalBoard && finalBoardCards.length > 0 && (
                                <div className="bg-slate-800/50 p-4 rounded-lg border border-slate-700">
                                    <h2 className="text-2xl font-semibold mb-4 text-violet-400 font-yugioh">{nbsp(t('finalBoardTitle'))}</h2>
                                    <div className="flex flex-wrap justify-center gap-4">
                                        {finalBoardCards.map(item => (
                                            <div key={item.id} className="flex flex-col items-center gap-2">
                                                <ExportCard card={item.card} size="normal" />
                                                <div className="text-center">
                                                    <p className="font-bold text-sm text-slate-300">{nbsp(item.zone)}</p>
                                                    {item.isDisruption && <p className="text-xs text-red-400 font-bold">{nbsp(t('finalBoardDisruption'))}</p>}
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>
                </div> 
            ); 
        };
        const RichTextEditor = ({ value, onChange }) => { 
            const editorRef = useRef(null); 
            useEffect(() => { 
                if (editorRef.current && editorRef.current.innerHTML !== value) { 
                    editorRef.current.innerHTML = value; 
                } 
            }, [value]); 
            
            const handleInput = () => { 
                if (editorRef.current) onChange(sanitizeHTML(editorRef.current.innerHTML)); 
            }; 
            
            const execCmd = (command, val = null) => { 
                document.execCommand('styleWithCSS', false, true); // Force spans over font tags
                document.execCommand(command, false, val); 
                editorRef.current.focus(); 
                // Manually trigger update to ensure state is saved after command
                handleInput();
            }; 
            
            return ( 
                <div className="rich-text-editor bg-[var(--color-surface-light)] rounded-lg"> 
                    <div className="toolbar flex items-center gap-2 mb-2 p-2 bg-slate-900/50 rounded-t-md border-b border-[var(--color-border)]"> 
                        <button onClick={() => execCmd('bold')} className="w-8 h-8 rounded hover:bg-slate-700"><b>B</b></button> 
                        <button onClick={() => execCmd('italic')} className="w-8 h-8 rounded hover:bg-slate-700"><i>I</i></button> 
                        <button onClick={() => execCmd('underline')} className="w-8 h-8 rounded hover:bg-slate-700"><u>U</u></button> 
                        <button onClick={() => execCmd('insertUnorderedList')} className="w-8 h-8 rounded hover:bg-slate-700">•</button> 
                        <input type="color" onChange={(e) => execCmd('foreColor', e.target.value)} title="Text Color" className="w-8 h-8 p-1 bg-transparent border-none rounded cursor-pointer" /> 
                    </div> 
                    <div
  ref={editorRef}
  contentEditable={true}
  className="p-3 min-h-[8rem] outline-none rounded-b-md leading-relaxed focus:ring-2 focus:ring-[var(--color-primary)]"
  onInput={handleInput}
  onBlur={handleInput}
  style={{ direction: 'ltr', unicodeBidi: 'plaintext', textAlign: 'left', transform: 'none' }}
></div> 
                </div> 
            ); 
        };

        const ExportOptionsModal = ({ show, onClose, onConfirm, exportOptions, setExportOptions, t }) => { if (!show) return null; return ( <div className="fixed inset-0 bg-black bg-opacity-75 backdrop-blur-sm flex items-center justify-center z-50 p-4"> <div className="bg-slate-900 border border-slate-700 rounded-lg shadow-xl p-6 max-w-md w-full relative"> <h3 className="text-xl font-bold mb-6 text-violet-300 text-center">{t('exportOptionsTitle')}</h3> <div className="space-y-4 mb-8"> {Object.keys(exportOptions.include).map(key => ( <label key={key} className="flex items-center gap-3 cursor-pointer p-2 rounded-md hover:bg-slate-700/50 transition-colors"> <input type="checkbox" checked={exportOptions.include[key]} onChange={e => setExportOptions(prev => ({ ...prev, include: { ...prev.include, [key]: e.target.checked } }))} className="h-5 w-5 bg-slate-600 border-slate-500 text-violet-500 focus:ring-violet-500 rounded" /> <span className="text-slate-200">{t(key + 'Title')}</span> </label> ))} 
                                    <div className="border-t border-slate-600 pt-4">
                                        <label className="block text-sm font-medium text-slate-300 mb-2">{t('exportLayout')}</label>
                                        <div className="flex gap-2">
                                            {[3, 4, 5, 6].map(num => (
                                                <button 
                                                    key={num}
                                                    onClick={() => setExportOptions(p => ({...p, stepsPerRow: num}))} 
                                                    className={`flex-1 py-2 text-sm rounded-md ${exportOptions.stepsPerRow === num ? 'bg-violet-600' : 'bg-slate-600 hover:bg-slate-500'}`}>
                                                    {num}xN
                                                </button>
                                            ))}
                                        </div>
                                    </div>
                                    <div className="border-t border-slate-600 pt-4"> <label className="block text-sm font-medium text-slate-300 mb-2">{t('exportQuality')}</label> <div className="flex gap-2"> <button onClick={() => setExportOptions(p => ({...p, scale: 1}))} className={`flex-1 py-2 text-sm rounded-md ${exportOptions.scale === 1 ? 'bg-violet-600' : 'bg-slate-600 hover:bg-slate-500'}`}>{t('qualityLow')}</button> <button onClick={() => setExportOptions(p => ({...p, scale: 2}))} className={`flex-1 py-2 text-sm rounded-md ${exportOptions.scale === 2 ? 'bg-violet-600' : 'bg-slate-600 hover:bg-slate-500'}`}>{t('qualityMedium')}</button> <button onClick={() => setExportOptions(p => ({...p, scale: 3}))} className={`flex-1 py-2 text-sm rounded-md ${exportOptions.scale === 3 ? 'bg-violet-600' : 'bg-slate-600 hover:bg-slate-500'}`}>{t('qualityHigh')}</button> </div> </div> </div> <div className="flex justify-end gap-4"> <button onClick={onClose} className="px-5 py-2 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-700">{t('cancel')}</button> <button onClick={onConfirm} className="px-5 py-2 bg-green-600 text-white font-semibold rounded-lg hover:bg-green-700">{t('confirmAndExport')}</button> </div> </div> </div> ); };
        
        const SaveComboModal = ({ show, onClose, onSave, t, isOnlineSaveEnabled }) => { const [name, setName] = useState(''); if (!show) return null; return ( <div className="fixed inset-0 bg-black bg-opacity-75 backdrop-blur-sm flex items-center justify-center z-50 p-4"> <div className="bg-slate-900 border border-slate-700 rounded-lg shadow-xl p-8 max-w-sm w-full relative"> <h3 className="text-xl font-bold mb-6 text-violet-300 text-center">{t('saveComboTitle')}</h3> <input type="text" value={name} onChange={(e) => setName(e.target.value)} placeholder={t('comboName')} className="w-full p-3 bg-slate-700 border border-slate-600 rounded-lg focus:ring-2 focus:ring-violet-500 focus:outline-none mb-6" /> <div className="flex justify-end gap-4"> <button onClick={onClose} className="px-5 py-2 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-700">{t('cancel')}</button> <button onClick={() => onSave(name)} disabled={!name} className="px-5 py-2 bg-green-600 text-white font-semibold rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed">{t('save')}</button> </div> </div> </div> ); };
        const LoadComboModal = ({ show, onClose, onSelect, onDelete, t, db, user, appId, isOnlineSaveEnabled }) => { const [savedCombos, setSavedCombos] = useState([]); const [deleteConfirm, setDeleteConfirm] = useState({ show: false, name: null }); 
            useEffect(() => { 
                if (show) { 
                    if (isOnlineSaveEnabled && db && user) {
                        const combosCol = db.collection('artifacts').doc(appId).collection('public').doc('data').collection('combos');
                        const unsubscribe = combosCol.orderBy("createdAt", "desc").onSnapshot(snapshot => {
                            const combos = snapshot.docs.map(doc => ({
                                id: doc.id,
                                ...doc.data()
                            }));
                            setSavedCombos(combos);
                        });
                        return () => unsubscribe();
                    } else {
                        const combos = Object.keys(localStorage).filter(key => key.startsWith(LOCAL_STORAGE_PREFIX)).map(key => ({ id: key.replace(LOCAL_STORAGE_PREFIX, '') })); 
                        setSavedCombos(combos); 
                    }
                } 
            }, [show, isOnlineSaveEnabled, db, user, appId]); 
            const handleDeleteClick = (name) => { setDeleteConfirm({ show: true, name }); }; 
            const confirmDelete = () => { onDelete(deleteConfirm.name); setDeleteConfirm({ show: false, name: null }); }; if (!show) return null; 
            return ( <div className="fixed inset-0 bg-black bg-opacity-75 backdrop-blur-sm flex items-center justify-center z-50 p-4"> <div className="bg-slate-900 border border-slate-700 rounded-lg shadow-xl p-6 max-w-2xl w-full relative"> <h3 className="text-xl font-bold mb-6 text-violet-300 text-center">{t('publicCombosTitle')}</h3> <div className="space-y-2 max-h-96 overflow-y-auto mb-6"> {savedCombos.length > 0 ? savedCombos.map(combo => ( <div key={combo.id} className="flex items-center justify-between p-3 bg-slate-800 rounded-lg hover:bg-slate-700/50"> <div className="flex-grow"> <p className="font-medium text-slate-200">{combo.id}</p> {combo.authorId && <p className="text-xs text-slate-400 truncate">{t('author')}: {combo.authorId}</p>} </div> <div className="flex gap-2 flex-shrink-0"> <button onClick={() => onSelect(combo.id)} className="px-3 py-1 text-sm bg-violet-600 text-white font-semibold rounded-md hover:bg-violet-700">Load</button> {user && combo.authorId === user.uid && <button onClick={() => handleDeleteClick(combo.id)} className="p-2 bg-red-600 text-white rounded-md hover:bg-red-700"><i className="fas fa-trash"></i></button>} </div> </div> )) : <p className="text-center text-slate-400 py-4">{t('noCombosSaved')}</p>} </div> <div className="flex justify-end"> <button onClick={onClose} className="px-5 py-2 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-700">{t('cancel')}</button> </div> </div> <ConfirmationModal show={deleteConfirm.show} title={t('delete')} message={t('deleteConfirmMessage', { comboName: deleteConfirm.name })} onConfirm={confirmDelete} onCancel={() => setDeleteConfirm({ show: false, name: null })} t={t} /> </div> ); };

        const Tutorial = ({ steps, onEnd, t, onStepChange }) => {
            const [stepIndex, setStepIndex] = useState(0);
            const [style, setStyle] = useState({ opacity: 0 });
            const [tooltipStyle, setTooltipStyle] = useState({ opacity: 0 });
            const currentStep = steps[stepIndex];
            const tooltipRef = useRef(null);

            const calculatePositions = useCallback(() => {
                if (!currentStep) return;
                const target = document.querySelector(currentStep.targetSelector);
                if (!target) {
                    console.warn(`Tutorial target not found: ${currentStep.targetSelector}`);
                    setStyle({ opacity: 0 });
                    setTooltipStyle({ opacity: 0 });
                    return;
                }
                const rect = target.getBoundingClientRect();
                const padding = 10;
                const zoomVal = getComputedStyle(document.body).zoom;
                const zoom = (zoomVal && !isNaN(parseFloat(zoomVal))) ? parseFloat(zoomVal) : 1;
                const top = (rect.top - padding / 2) / zoom;
                const left = (rect.left - padding / 2) / zoom;
                const width = (rect.width + padding) / zoom;
                const height = (rect.height + padding) / zoom;
                setStyle({ width: `${width}px`, height: `${height}px`, top: `${top}px`, left: `${left}px`, opacity: 1 });
                const tooltipRect = tooltipRef.current ? tooltipRef.current.getBoundingClientRect() : { width: 300, height: 150 };
                let ttTop, ttLeft;
                if (rect.bottom + 15 + tooltipRect.height < window.innerHeight) {
                  ttTop = (rect.bottom + 15) / zoom;
                } else if (rect.top - 15 - tooltipRect.height > 0) {
                  ttTop = (rect.top - 15 - tooltipRect.height) / zoom;
                } else {
                  ttTop = (window.innerHeight - tooltipRect.height) / (2 * zoom);
                }
                ttLeft = (rect.left + (rect.width / 2) - (tooltipRect.width / 2)) / zoom;
                const maxL = (window.innerWidth - tooltipRect.width - 10) / zoom;
                ttLeft = Math.max(10 / zoom, Math.min(ttLeft, maxL));
                setTooltipStyle({ top: `${ttTop}px`, left: `${ttLeft}px`, opacity: 1 });
            }, [currentStep]);

            useEffect(() => {
                if (!currentStep) return;

                let observer;
                let resizeHandler;
                let scrollHandler;
                let intervalId;
                let ro;

                const cleanup = () => {
                    window.removeEventListener('resize', resizeHandler);
                    window.removeEventListener('scroll', scrollHandler, true);
                    if (observer) observer.disconnect();
                    if (ro) ro.disconnect();
                    if (intervalId) clearInterval(intervalId);
                };

                const setupTutorialStep = () => {
                    calculatePositions();
                    
                    ro = new ResizeObserver(calculatePositions);
                    const tgt = document.querySelector(currentStep.targetSelector);
                    if (tgt) ro.observe(tgt);
                    resizeHandler = calculatePositions;
                    scrollHandler = calculatePositions;
                    window.addEventListener('resize', resizeHandler);
                    window.addEventListener('scroll', scrollHandler, true);
                    observer = new MutationObserver(calculatePositions);
                    if (document.body) {
                        observer.observe(document.body, { childList: true, subtree: true, attributes: true });
                    }
                };
                
                let attempts = 0;
                const maxAttempts = 20; // Try for 2 seconds (20 * 100ms)
                intervalId = setInterval(() => {
                    const target = document.querySelector(currentStep.targetSelector);
                    if (target) {
                        clearInterval(intervalId);
                        intervalId = null;
                        target.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
                        setTimeout(setupTutorialStep, 300);
                    } else {
                        attempts++;
                        if (attempts > maxAttempts) {
                            clearInterval(intervalId);
                            intervalId = null;
                            console.warn(`Tutorial target not found after ${maxAttempts} attempts: ${currentStep.targetSelector}`);
                        }
                    }
                }, 100);

                return cleanup;
            }, [stepIndex, currentStep, calculatePositions]);


            if (!currentStep) return null;
            const handleNext = () => {
                if (onStepChange) onStepChange(stepIndex + 1);
                if (stepIndex < steps.length - 1) {
                    setStepIndex(stepIndex + 1);
                } else {
                    onEnd();
                }
            };
            return (
                <div className="tutorial-overlay">
                    <div className="tutorial-spotlight" style={style}></div>
                    <div ref={tooltipRef} className="tutorial-tooltip" style={tooltipStyle}>
                        <h4 className="text-lg font-bold text-violet-400 mb-2">{currentStep.title}</h4>
                        <p className="text-sm mb-4">{currentStep.content}</p>
                        <div className="flex justify-between items-center">
                            <button onClick={onEnd} className="text-sm text-slate-400 hover:text-white">{t('tutorialSkip')}</button>
                            <button onClick={handleNext} className="px-4 py-2 bg-violet-600 text-white font-semibold rounded-lg hover:bg-violet-700">
                                {stepIndex === steps.length - 1 ? t('tutorialFinish') : t('tutorialNext')}
                            </button>
                        </div>
                    </div>
                </div>
            );
        };
        const Notification = ({ message, show, t }) => { const elRef = useRef(null); useEffect(() => { if (show) { elRef.current.classList.add('show'); elRef.current.classList.remove('hide'); } else { elRef.current.classList.add('hide'); elRef.current.classList.remove('show'); } }, [show]); return ( <div ref={elRef} className="notification hide fixed top-5 left-1/2 -translate-x-1/2 bg-green-500/80 text-white font-bold px-6 py-2 rounded-full shadow-lg z-50"> {message} </div> ); };
        
        const CustomCardModal = ({ show, onClose, onSave, t, existingCard }) => {
            const [cardData, setCardData] = useState({
                name: '', type: 'Effect Monster', desc: '', atk: '', def: '', image_url: '',
            });
            const [imagePreview, setImagePreview] = useState('');

            useEffect(() => {
                if (existingCard) {
                    setCardData(existingCard);
                    setImagePreview(existingCard.image_url);
                } else {
                    setCardData({ name: '', type: 'Effect Monster', desc: '', atk: '', def: '', image_url: '' });
                    setImagePreview('');
                }
            }, [existingCard, show]);

            if (!show) return null;

            const handleInputChange = (e) => {
                const { name, value } = e.target;
                setCardData(prev => ({ ...prev, [name]: sanitizeHTML(value) }));
            };

            const handleImageUpload = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        setImagePreview(reader.result);
                        setCardData(prev => ({ ...prev, image_url: reader.result }));
                    };
                    reader.readAsDataURL(file);
                }
            };

            const handleSave = () => {
                const finalCard = {
                    ...cardData,
                    isCustom: true,
                    instanceId: existingCard ? existingCard.instanceId : generateId(),
                    ygoprodeck_id: existingCard ? existingCard.ygoprodeck_id : `custom_${Date.now()}`
                };
                onSave(finalCard);
                onClose();
            };

            return (
                <div className="fixed inset-0 bg-black bg-opacity-75 backdrop-blur-sm flex items-center justify-center z-50 p-4">
                    <div className="bg-slate-900 border border-slate-700 rounded-lg shadow-xl p-6 max-w-2xl w-full relative" onClick={e => e.stopPropagation()}>
                        <button onClick={onClose} className="absolute top-3 right-3 text-gray-400 hover:text-white text-2xl font-bold">×</button>
                        <h3 className="text-xl font-bold mb-6 text-violet-300 text-center">{t('customCardTitle')}</h3>
                        <div className="flex flex-col md:flex-row gap-6">
                            <div className="flex-1 space-y-4">
                                <input type="text" name="name" value={cardData.name} onChange={handleInputChange} placeholder={t('cardName')} className="w-full p-2 bg-slate-700 border border-slate-600 rounded-lg focus:ring-2 focus:ring-violet-500 focus:outline-none" />
                                <select name="type" value={cardData.type} onChange={handleInputChange} className="w-full p-2 bg-slate-700 border border-slate-600 rounded-lg">
                                    {CARD_TYPES.map(type => <option key={type} value={type}>{type}</option>)}
                                </select>
                                <textarea name="desc" value={cardData.desc} onChange={handleInputChange} placeholder={t('cardDescription')} rows="5" className="w-full p-2 bg-slate-700 border border-slate-600 rounded-lg"></textarea>
                                <div className="flex gap-4">
                                    <input type="text" name="atk" value={cardData.atk} onChange={handleInputChange} placeholder={t('attack')} className="w-full p-2 bg-slate-700 border border-slate-600 rounded-lg" />
                                    <input type="text" name="def" value={cardData.def} onChange={handleInputChange} placeholder={t('defense')} className="w-full p-2 bg-slate-700 border border-slate-600 rounded-lg" />
                                </div>
                                <input type="file" accept="image/*" onChange={handleImageUpload} className="w-full text-sm text-slate-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-violet-50 file:text-violet-700 hover:file:bg-violet-100" />
                            </div>
                            <div className="flex-shrink-0 w-48">
                                <p className="text-center mb-2">{t('preview')}</p>
                                <img src={imagePreview || 'https://placehold.co/200x292/1e293b/a78bfa?text=Upload+Image'} alt="Preview" className="w-full rounded-lg shadow-md" />
                            </div>
                        </div>
                        <div className="flex justify-end gap-4 mt-6">
                            <button onClick={onClose} className="px-5 py-2 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-700">{t('cancel')}</button>
                            <button onClick={handleSave} className="px-5 py-2 bg-green-600 text-white font-semibold rounded-lg hover:bg-green-700">{t('create')}</button>
                        </div>
                    </div>
                </div>
            );
        };

        const PopularCardsCarousel = ({ onCardClick, t, cardPool }) => {
            const popularCardNames = ["Ash Blossom & Joyous Spring", "Maxx \"C\"", "Infinite Impermanence", "Effect Veiler", "Nibiru, the Primal Being", "Pot of Prosperity", "Called by the Grave", "Accesscode Talker", "Divine Arsenal AA-ZEUS - Sky Thunder", "Baronne de Fleur", "Spright Elf", "Tearlaments Kitkallos", "Change of Heart", "Monster Reborn", "Raigeki", "Harpie's Feather Duster", "Pot of Desires", "Forbidden Droplet"];
            const [cards, setCards] = useState([]);
            const [isCarouselOpen, setIsCarouselOpen] = useState(true);
            const scrollRef = useRef(null);

            useEffect(() => {
                const fetchCards = async () => {
                    try {
                        const cardData = await Promise.all(
                            popularCardNames.map(name => 
                                fetch(`${YGOPRODECK_API_BASE_URL}?fname=${encodeURIComponent(name)}`)
                                    .then(res => res.json())
                                    .then(data => data.data[0])
                            )
                        );
                        setCards(cardData.filter(Boolean));
                    } catch (error) {
                        console.error("Failed to fetch popular cards:", error);
                    }
                };
                fetchCards();
            }, []);

            const scroll = (direction) => {
                if (scrollRef.current) {
                    scrollRef.current.scrollBy({ left: direction * 300, behavior: 'smooth' });
                }
            };
            
            if (cards.length === 0) return <div className="flex justify-center p-4"><Spinner /></div>;
            
            const availableCards = cards.filter(card => !cardPool.some(poolCard => poolCard.ygoprodeck_id === card.id));

            return (
                <div className="relative my-4 popular-cards-carousel">
                    <h4 onClick={() => setIsCarouselOpen(!isCarouselOpen)} className="text-sm font-semibold text-slate-400 mb-2 flex justify-between items-center cursor-pointer">
                        <span>Popular Cards</span>
                        <i className={`fas fa-chevron-down transition-transform duration-300 ${isCarouselOpen ? '' : '-rotate-90'}`}></i>
                    </h4>
                    <div className={`transition-all duration-500 ease-in-out overflow-hidden ${isCarouselOpen ? 'max-h-60 opacity-100' : 'max-h-0 opacity-0'}`}>
                        <div className="relative pt-2">
                            <button onClick={() => scroll(-1)} className="absolute left-0 top-1/2 -translate-y-1/2 z-10 bg-slate-700/50 hover:bg-slate-600 rounded-full p-1 text-white">
                                <i className="fas fa-chevron-left"></i>
                            </button>
                            <div ref={scrollRef} className="flex overflow-x-auto gap-3 pb-2 scroll-smooth" style={{ scrollbarWidth: 'none' }}>
                                {availableCards.map(card => (
                                    <div key={card.id} className="flex-shrink-0">
                                        <CardDisplay card={createComboCardInstance(card, 'https://images.weserv.nl/?url=')} size="small" onClick={() => onCardClick(card)} />
                                    </div>
                                ))}
                            </div>
                            <button onClick={() => scroll(1)} className="absolute right-0 top-1/2 -translate-y-1/2 z-10 bg-slate-700/50 hover:bg-slate-600 rounded-full p-1 text-white">
                                <i className="fas fa-chevron-right"></i>
                            </button>
                        </div>
                    </div>
                </div>
            );
        };
        
        const EmptyState = ({ icon, title, message, action }) => (
            <div className="empty-state">
                <i className={`fas ${icon}`}></i>
                <h4>{title}</h4>
                <p className="text-sm">{message}</p>
                {action && <div className="mt-4">{action}</div>}
            </div>
        );

        const RestoreNotification = ({ onRestore, onDismiss, t }) => (
            <div className="fixed bottom-5 left-1/2 -translate-x-1/2 bg-slate-800 border border-slate-600 text-white font-bold px-6 py-3 rounded-lg shadow-lg z-50 flex items-center gap-4 animate-fadeInUp">
                <span>{t('autosaveRestore')}</span>
                <button onClick={onRestore} className="btn text-sm bg-green-600 px-3 py-1 rounded-md hover:bg-green-700">{t('restore')}</button>
                <button onClick={onDismiss} className="btn text-sm bg-slate-600 px-3 py-1 rounded-md hover:bg-slate-500">{t('dismiss')}</button>
            </div>
        );

        const Toast = ({ message, onUndo, onClose, t }) => {
            useEffect(() => {
                const timer = setTimeout(onClose, 5000);
                return () => clearTimeout(timer);
            }, [onClose]);

            return (
                <div className="fixed bottom-5 left-1/2 -translate-x-1/2 bg-slate-800 border border-slate-600 text-white font-bold px-6 py-3 rounded-lg shadow-lg z-50 flex items-center gap-4 animate-fadeInUp">
                    <span>{message}</span>
                    <button onClick={onUndo} className="btn text-sm text-amber-300 hover:underline">{t('undo')}</button>
                    <button onClick={onClose} className="text-slate-400 hover:text-white">&times;</button>
                </div>
            );
        };

        const TemplatesModal = ({ show, onClose, onSelect, t }) => {
            const [confirmLoad, setConfirmLoad] = useState(null);
            
            const templates = [
                {
                    name: "Basic Salamangreat Combo",
                    description: "A simple 1-card combo using Salamangreat Gazelle.",
                    state: {
                        cardPool: [ { instanceId: "sg_1", ygoprodeck_id: 27348498, name: "Salamangreat Gazelle", type: "Effect Monster", image_url_small: "https://images.weserv.nl/?url=images.ygoprodeck.com/images/cards_small/27348498.jpg" }, { instanceId: "sb_1", ygoprodeck_id: 50122884, name: "Salamangreat Balelynx", type: "Link Monster", image_url_small: "https://images.weserv.nl/?url=images.ygoprodeck.com/images/cards_small/50122884.jpg" }, { instanceId: "ss_1", ygoprodeck_id: 86438692, name: "Salamangreat Sunlight Wolf", type: "Link Monster", image_url_small: "https://images.weserv.nl/?url=images.ygoprodeck.com/images/cards_small/86438692.jpg" } ],
                        startingHand: [[{ instanceId: "sg_1", quantity: 1 }]],
                        comboSteps: [
                            { type: "step", id: generateId(), mainCardInstanceId: "sg_1", actionType: "Normal Summon", actionDescription: "Summon Gazelle" },
                            { type: "step", id: generateId(), mainCardInstanceId: "sg_1", actionType: "Link Summon", actionDescription: "Link into Balelynx", targetCards: [{instanceId: "sb_1"}] },
                        ],
                        finalBoardCards: [{ id: generateId(), card: { instanceId: "ss_1", name: "Salamangreat Sunlight Wolf" }, zone: "Extra Monster 1", isDisruption: true }],
                        comboTitle: "Basic Salamangreat Combo",
                        notes: "This is a foundational combo for the deck."
                    }
                },
                 {
                    name: "Kashtira Zone Lock",
                    description: "A standard line to end on Arise-Heart and lock zones.",
                    state: {
                        cardPool: [ { instanceId: "kash_1", ygoprodeck_id: 21534435, name: "Kashtira Unicorn", type: "Effect Monster", image_url_small: "https://images.weserv.nl/?url=images.ygoprodeck.com/images/cards_small/21534435.jpg" }, { instanceId: "kash_2", ygoprodeck_id: 95308449, name: "Kashtira Fenrir", type: "Effect Monster", image_url_small: "https://images.weserv.nl/?url=images.ygoprodeck.com/images/cards_small/95308449.jpg" }, { instanceId: "kash_3", ygoprodeck_id: 59683162, name: "Kashtira Arise-Heart", type: "Xyz Monster", image_url_small: "https://images.weserv.nl/?url=images.ygoprodeck.com/images/cards_small/59683162.jpg" } ],
                        startingHand: [[{ instanceId: "kash_1", quantity: 1 }]],
                        comboSteps: [
                             { type: "step", id: generateId(), mainCardInstanceId: "kash_1", actionType: "Special Summon", actionDescription: "Summon Unicorn" },
                             { type: "step", id: generateId(), mainCardInstanceId: "kash_1", actionType: "Activate Effect", actionDescription: "Search for Kashtira Birth" },
                        ],
                        finalBoardCards: [{ id: generateId(), card: { instanceId: "kash_3", name: "Kashtira Arise-Heart" }, zone: "Extra Monster 1", isDisruption: true }],
                        comboTitle: "Kashtira Zone Lock",
                        notes: "Requires no opponent interaction."
                    }
                }
            ];

            if (!show) return null;
            
            const handleSelect = (template) => {
                setConfirmLoad(template);
            };

            const handleConfirm = () => {
                onSelect(confirmLoad.state);
                setConfirmLoad(null);
            };

            return (
                 <div className="fixed inset-0 bg-black bg-opacity-75 backdrop-blur-sm flex items-center justify-center z-50 p-4">
                    <div className="bg-slate-900 border border-slate-700 rounded-lg shadow-xl p-6 max-w-lg w-full relative">
                        <h3 className="text-xl font-bold mb-6 text-violet-300 text-center">{t('loadTemplate')}</h3>
                        <div className="space-y-3 max-h-96 overflow-y-auto">
                            {templates.map(template => (
                                <div key={template.name} className="p-4 bg-slate-800 rounded-lg hover:bg-slate-700/50">
                                    <h4 className="font-bold text-amber-300">{template.name}</h4>
                                    <p className="text-sm text-slate-300 mt-1">{template.description}</p>
                                    <button onClick={() => handleSelect(template)} className="btn mt-2 px-3 py-1 text-sm bg-violet-600 text-white font-semibold rounded-md hover:bg-violet-700">Load</button>
                                </div>
                            ))}
                        </div>
                         <div className="flex justify-end mt-6">
                            <button onClick={onClose} className="px-5 py-2 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-700">{t('cancel')}</button>
                        </div>
                    </div>
                    <ConfirmationModal
                        show={!!confirmLoad}
                        title={t('loadTemplate')}
                        message={t('templateConfirm')}
                        onConfirm={handleConfirm}
                        onCancel={() => setConfirmLoad(null)}
                        t={t}
                    />
                 </div>
            );
        };

        const AutoResizeTextarea = ({ value, ...props }) => {
            const textareaRef = useRef(null);
            useLayoutEffect(() => {
                const textarea = textareaRef.current;
                if (textarea) {
                    textarea.style.height = 'auto';
                    textarea.style.height = `${textarea.scrollHeight}px`;
                }
            }, [value]);
            return <textarea ref={textareaRef} value={value} {...props} />;
        };

        const ComboStats = ({ stats, t }) => {
            if (!stats) return null;

            const totalCards = stats.types.Monster + stats.types.Spell + stats.types.Trap;
            const typeDistribution = [
                { name: t('monster'), value: stats.types.Monster, color: 'bg-amber-500' },
                { name: t('spell'), value: stats.types.Spell, color: 'bg-teal-500' },
                { name: t('trap'), value: stats.types.Trap, color: 'bg-fuchsia-600' },
            ].filter(item => item.value > 0);

            const attributeColors = {
                DARK: 'bg-purple-600', LIGHT: 'bg-yellow-300 text-black', FIRE: 'bg-red-600',
                WATER: 'bg-blue-500', WIND: 'bg-green-500', EARTH: 'bg-orange-800', DIVINE: 'bg-yellow-500'
            };
            const activeAttributes = Object.entries(stats.attributes).filter(([_, value]) => value > 0);
            
            return (
                <div className="p-4 pt-0">
                    <div className="p-4 bg-black/20 rounded-lg space-y-4">
                        <div>
                            <h4 className="font-semibold mb-2 text-lg text-[var(--color-text)]">{t('statsCardTypes')} ({totalCards})</h4>
                            <div className="w-full flex h-6 rounded-md overflow-hidden bg-[var(--color-surface-light)]">
                                {typeDistribution.map(type => (
                                    <div key={type.name} style={{ width: `${(type.value / totalCards) * 100}%` }} className={`${type.color} flex items-center justify-center text-xs font-bold text-white`} data-tooltip={`${type.name}: ${type.value}`}>
                                        {Math.round((type.value / totalCards) * 100)}%
                                    </div>
                                ))}
                            </div>
                        </div>
                        {activeAttributes.length > 0 && (
                             <div>
                                <h4 className="font-semibold mb-2 text-lg text-[var(--color-text)]">{t('statsAttributes')}</h4>
                                <div className="flex flex-wrap gap-2">
                                    {activeAttributes.map(([name, value]) => (
                                        <div key={name} className={`flex items-center gap-2 px-3 py-1 rounded-full text-white text-sm font-medium ${attributeColors[name]}`}>
                                            <span>{name}</span>
                                            <span className="bg-black/20 w-5 h-5 text-xs flex items-center justify-center rounded-full">{value}</span>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const App = () => {
            const [isLoading, setIsLoading] = useState(true);
            const [language, setLanguage] = useState(() => { const saved = localStorage.getItem('ygo_lang'); return saved === 'es' || saved === 'en' ? saved : (navigator.language?.startsWith('es') ? 'es' : 'en'); });
            const [searchTerm, setSearchTerm] = useState('');
            const [searchResults, setSearchResults] = useState([]);
            const [suggestions, setSuggestions] = useState([]);
            const [isLoadingSearch, setIsLoadingSearch] = useState(false);
            const [selectedCardForZoom, setSelectedCardForZoom] = useState(null);
            const [showClearConfirmModal, setShowClearConfirmModal] = useState(false);
            const [isExportingPng, setIsExportingPng] = useState(false);
            const [pngPreviewUrl, setPngPreviewUrl] = useState(null);
            const [draggedItem, setDraggedItem] = useState(null);
            const [showExportOptionsModal, setShowExportOptionsModal] = useState(false);
            const [filters, setFilters] = useState({ type: '', attribute: '', level: '', archetype: '' });
            const [archetypes, setArchetypes] = useState([]);
            const [allTokens, setAllTokens] = useState([]);
            const [isAddingToken, setIsAddingToken] = useState(false);
            const [exportProgress, setExportProgress] = useState(0);
            const [exportMessage, setExportMessage] = useState('');
            const [isApiReady, setIsApiReady] = useState(false);
            const [apiCheckMessage, setApiCheckMessage] = useState('');
            const [currentPage, setCurrentPage] = useState(1);
            const [contextMenu, setContextMenu] = useState({ card: null, x: 0, y: 0, options: [] });
            const [showFilters, setShowFilters] = useState(false);
            const [highlightedCardIds, setHighlightedCardIds] = useState([]);
            const [isLangMenuOpen, setIsLangMenuOpen] = useState(false);
            const [isSearchPanelOpen, setIsSearchPanelOpen] = useState(window.innerWidth > 1024);
            const [isCardPoolOpen, setIsCardPoolOpen] = useState(true);
            const [isStatsOpen, setIsStatsOpen] = useState(true);
            const [isStartingHandOpen, setIsStartingHandOpen] = useState(true);
            const [isFinalBoardOpen, setIsFinalBoardOpen] = useState(true);
            const [showSaveModal, setShowSaveModal] = useState(false);
            const [showLoadModal, setShowLoadModal] = useState(false);
            const [tutorialState, setTutorialState] = useState({ active: false, steps: [], key: 'main' });
            const [notification, setNotification] = useState({ show: false, message: '' });
            const [showRestoreNotification, setShowRestoreNotification] = useState(false);
            const [toast, setToast] = useState({ show: false, message: '', onUndo: null });
            const [isFlyoutButtonVisible, setIsFlyoutButtonVisible] = useState(false);
            const [isFlyoutPoolOpen, setIsFlyoutPoolOpen] = useState(false);
            const [justAddedCardId, setJustAddedCardId] = useState(null);
            const [hoveredCard, setHoveredCard] = useState({ card: null, x: 0, y: 0 });
            const [dragOverIndex, setDragOverIndex] = useState(null);
            const [touchDragGhost, setTouchDragGhost] = useState(null);
            const [showCustomCardModal, setShowCustomCardModal] = useState(false);
            const [editingCustomCard, setEditingCustomCard] = useState(null);
            const [deleteFromIndex, setDeleteFromIndex] = useState(null);
            const [zonePickerStepId, setZonePickerStepId] = useState(null);
            
            // Firebase State
            const [db, setDb] = useState(null);
            const [user, setUser] = useState(null);
            const [isOnlineSaveEnabled, setIsOnlineSaveEnabled] = useState(false);
            const appId = useMemo(() => typeof __app_id !== 'undefined' ? __app_id : 'default-app-id', []);

            const [exportOptions, setExportOptions] = useState({ include: { startingHand: true, comboSteps: true, finalBoard: true, notes: true, comboStats: true }, scale: 2, stepsPerRow: 4 });
            const initialComboState = { cardPool: [], startingHand: [[]], comboSteps: [], finalBoardCards: [], comboTitle: '', notes: '', };
            const { state: comboState, setState: setComboState, loadState, undo, redo, canUndo, canRedo } = useHistoryState(initialComboState);
            const { cardPool, startingHand, comboSteps, finalBoardCards, comboTitle, notes } = comboState;
            const searchAbortController = useRef(null);
            const langMenuRef = useRef(null);
            const cardPoolSectionRef = useRef(null);
            
            useEffect(() => { document.documentElement.lang = language; localStorage.setItem('ygo_lang', language); }, [language]);
            const t = useCallback((key, params = {}) => { let str = (translations[language] && translations[language][key]) || translations['en'][key] || key; for (const param in params) { str = str.replace(`{${param}}`, params[param]); } return str; }, [language]);
            const tutorialSteps = useMemo(() => ({ main: [ { targetSelector: '#search-panel', title: t('tutorialTitleSearch'), content: t('tutorialContentSearch') }, { targetSelector: '.popular-cards-carousel', title: t('tutorialTitlePopularCards'), content: t('tutorialContentPopularCards') }, { targetSelector: '.card-pool', title: t('tutorialTitlePool'), content: t('tutorialContentPool') }, { targetSelector: '.starting-hand', title: t('tutorialTitleHand'), content: t('tutorialContentHand') }, { targetSelector: '.combo-steps', title: t('tutorialTitleSteps'), content: t('tutorialContentSteps') }, { targetSelector: '.final-board', title: t('tutorialTitleFinalBoard'), content: t('tutorialContentFinalBoard') }, { targetSelector: '.notes-section', title: t('tutorialTitleNotes'), content: t('tutorialContentNotes') }, { targetSelector: '.main-actions', title: t('tutorialTitleActions'), content: t('tutorialContentActions') }, ], stepActions: [ { targetSelector: '.combo-step-card .tutorial-action-select', title: t('tutorialTitleStepActionSelect'), content: t('tutorialContentStepActionSelect') }, { targetSelector: '.combo-step-card .tutorial-vulnerability-btn', title: t('tutorialTitleStepVulnerability'), content: t('tutorialContentStepVulnerability') }, { targetSelector: '.combo-step-card .tutorial-add-target-btn', title: t('tutorialTitleStepAffectedCards'), content: t('tutorialContentStepAffectedCards') }, { targetSelector: '.combo-step-card .tutorial-description-input', title: t('tutorialTitleStepDescription'), content: t('tutorialContentStepDescription') }, ] }), [t]);
            const IMAGE_PROXY = 'https://images.weserv.nl/?url=';

            // Firebase Initialization Effect
            useEffect(() => {
                try {
                    const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
                    if (!firebaseConfig || !window.firebase) {
                        console.warn("Firebase config not found. Saving will be local-only.");
                        setIsOnlineSaveEnabled(false);
                        return;
                    }

                    if (firebase.apps.length === 0) {
                        firebase.initializeApp(firebaseConfig);
                    }
                    
                    const authInstance = firebase.auth();
                    const dbInstance = firebase.firestore();
                    firebase.firestore.setLogLevel('debug');
                    setDb(dbInstance);
                    setIsOnlineSaveEnabled(true);

                    const unsubscribe = authInstance.onAuthStateChanged(async (firebaseUser) => {
                        if (firebaseUser) {
                            setUser(firebaseUser);
                        } else {
                            try {
                                const token = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
                                if (token) {
                                    await authInstance.signInWithCustomToken(token);
                                } else {
                                    await authInstance.signInAnonymously();
                                }
                            } catch (error) {
                                console.error("Firebase sign-in failed:", error);
                                setIsOnlineSaveEnabled(false);
                            }
                        }
                    });
                    return () => unsubscribe();
                } catch (error) {
                    console.error("Firebase initialization failed:", error);
                    setIsOnlineSaveEnabled(false);
                }
            }, []);

            useEffect(() => {
                const splashScreen = document.getElementById('splash-screen');
                if (isApiReady) {
                    const firstVisit = !localStorage.getItem('ygo_tutorial_main_completed');
                    const splashTimer = setTimeout(() => {
                        if (splashScreen) splashScreen.classList.add('hidden');
                        setIsLoading(false);
                        if(firstVisit) {
                           setTutorialState({ active: true, steps: tutorialSteps.main, key: 'main' });
                        }
                        const footer = document.getElementById('app-footer');
                        if (footer) footer.classList.add('visible');
                    }, 2000);
                    return () => clearTimeout(splashTimer);
                }
            }, [isApiReady, tutorialSteps.main]);
            
            useEffect(() => {
                const handleScroll = () => {
                    if (cardPoolSectionRef.current) {
                        const rect = cardPoolSectionRef.current.getBoundingClientRect();
                        setIsFlyoutButtonVisible(rect.bottom < 50);
                    }
                };
                window.addEventListener('scroll', handleScroll);
                return () => window.removeEventListener('scroll', handleScroll);
            }, []);

            useEffect(() => {
                const autoSaveTimer = setTimeout(() => {
                    if (cardPool.length > 0 || comboSteps.length > 0 || finalBoardCards.length > 0 || comboTitle || notes) {
                        localStorage.setItem(AUTO_SAVE_KEY, JSON.stringify(comboState));
                    }
                }, 10000);
                return () => clearTimeout(autoSaveTimer);
            }, [comboState]);

            useEffect(() => {
                const autoSavedData = localStorage.getItem(AUTO_SAVE_KEY);
                if (autoSavedData) {
                    setShowRestoreNotification(true);
                }
            }, []);

            const handleRestore = () => {
                const autoSavedData = localStorage.getItem(AUTO_SAVE_KEY);
                if (autoSavedData) {
                    try {
                        const loaded = JSON.parse(autoSavedData);
                        loadState(loaded, "Restored from Autosave");
                    } catch (e) { console.error("Failed to parse autosaved combo", e); }
                }
                setShowRestoreNotification(false);
            };

            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        if (e.key === 'z') { e.preventDefault(); undo(); }
                        if (e.key === 'y') { e.preventDefault(); redo(); }
                        if (e.key === 's') { e.preventDefault(); setShowSaveModal(true); }
                    }
                    if (e.key === 'Escape') {
                        if (pngPreviewUrl) setPngPreviewUrl(null);
                        else if (selectedCardForZoom) setSelectedCardForZoom(null);
                        else if (showClearConfirmModal) setShowClearConfirmModal(false);
                        else if (showExportOptionsModal) setShowExportOptionsModal(false);
                        else if (showSaveModal) setShowSaveModal(false);
                        else if (showLoadModal) setShowLoadModal(false);
                        else if (showCustomCardModal) setShowCustomCardModal(false);
                        else if (contextMenu.card) closeContextMenu();
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [undo, redo, pngPreviewUrl, selectedCardForZoom, showClearConfirmModal, showExportOptionsModal, showSaveModal, showLoadModal, showCustomCardModal, contextMenu.card]);


            useEffect(() => {
                const urlParams = new URLSearchParams(window.location.search);
                const comboData = urlParams.get('combo');
                if (comboData) {
                    try {
                        const jsonString = pako.inflate(atob(comboData), { to: 'string' });
                        const loaded = JSON.parse(jsonString);
                        loadState(loaded, "Loaded from URL");
                        setNotification({ show: true, message: t('comboLoadedFromUrl') });
                        window.history.replaceState({}, document.title, window.location.pathname);
                    } catch (e) {
                        console.error("Failed to load combo from URL:", e);
                        setNotification({ show: true, message: t('comboLoadFromUrlError') });
                    }
                }
            }, []);

            useEffect(() => {
                setApiCheckMessage(t('apiCheck'));
                fetch(`${YGOPRODECK_API_BASE_URL}?fname=Dark Magician`)
                    .then(res => res.ok ? res.json() : Promise.reject('API check failed'))
                    .then(() => {
                        setIsApiReady(true);
                        setApiCheckMessage(t('apiCheckSuccess'));
                    })
                    .catch(err => {
                        setIsApiReady(false);
                        setApiCheckMessage(t('apiCheckFail'));
                        console.error(err);
                    });
            }, [t]); 

            useEffect(() => { const mainTutorialCompleted = localStorage.getItem('ygo_tutorial_main_completed'); const stepActionsTutorialCompleted = localStorage.getItem('ygo_tutorial_stepActions_completed'); if (mainTutorialCompleted && !stepActionsTutorialCompleted && comboSteps.length === 1) { setTimeout(() => { setTutorialState({ active: true, steps: tutorialSteps.stepActions, key: 'stepActions' }); }, 100); } }, [comboSteps.length, tutorialSteps.stepActions]);
            useEffect(() => { if (notification.show) { const timer = setTimeout(() => { setNotification({ show: false, message: '' }); }, 2000); return () => clearTimeout(timer); } }, [notification.show]);
            useEffect(() => { const handleClickOutside = (event) => { if (langMenuRef.current && !langMenuRef.current.contains(event.target)) setIsLangMenuOpen(false); }; document.addEventListener('mousedown', handleClickOutside); return () => document.removeEventListener('mousedown', handleClickOutside); }, []);
            
            useEffect(() => {
                if (justAddedCardId) {
                    const timer = setTimeout(() => setJustAddedCardId(null), 500);
                    return () => clearTimeout(timer);
                }
            }, [justAddedCardId]);

            useEffect(() => {
                if (comboTitle) {
                    document.title = `${comboTitle} | Yu-Gi-Oh! Combo maker`;
                } else {
                    document.title = 'Yu-Gi-Oh! Combo maker App';
                }
            }, [comboTitle]);

            const debouncedSearch = useCallback(debounce(async (term, currentFilters, isForSuggestions = false) => {
                if (!isApiReady || (!term && !Object.values(currentFilters).some(v => v))) {
                    setSearchResults([]);
                    setSuggestions([]);
                    return;
                }
                if (searchAbortController.current) {
                    searchAbortController.current.abort();
                }
                searchAbortController.current = new AbortController();
                
                if (!isForSuggestions) {
                    setIsLoadingSearch(true);
                    setCurrentPage(1);
                }

                let url = new URL(YGOPRODECK_API_BASE_URL);
                if (term) url.searchParams.append('fname', term);
                Object.entries(currentFilters).forEach(([key, value]) => {
                    if (value) url.searchParams.append(key, value);
                });

                const blankImage = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/5+AAgUBAQ8DFwAAAABJRU5ErkJggg==';

                try {
                    const res = await fetch(url.toString(), { signal: searchAbortController.current.signal });
                    if (!res.ok) throw new Error("Failed to fetch");
                    const data = await res.json();
                    if (isForSuggestions) {
                        setSuggestions(data.data?.slice(0, 10) || []);
                    } else {
                        setSearchResults(data.data || []);
                        setSuggestions([]);
                    }
                } catch (error) {
                    if (error.name !== 'AbortError') {
                        console.error("Error fetching card data:", error);
                        if (!isForSuggestions) setSearchResults([]);
                        setSuggestions([]);
                    }
                } finally {
                    if (!isForSuggestions) setIsLoadingSearch(false);
                }
            }, 300), [t, isApiReady]);

            useEffect(() => {
                if (searchTerm) {
                    debouncedSearch(searchTerm, filters, true);
                } else {
                    setSuggestions([]);
                }
            }, [searchTerm, debouncedSearch, filters]);

            const handleSearchSubmit = (term) => {
                setSearchTerm(term);
                debouncedSearch(term, filters, false);
            };

            useEffect(() => { if (!isApiReady) return; fetch('https://db.ygoprodeck.com/api/v7/archetypes.php').then(res => res.json()).then(data => setArchetypes(data.map(a => a.archetype_name).sort())).catch(err => console.error("Failed to fetch archetypes", err)); fetch('https://db.ygoprodeck.com/api/v7/cardinfo.php?type=token').then(res => res.json()).then(data => setAllTokens(data.data || [])).catch(err => console.error("Failed to fetch tokens", err)); }, [isApiReady]);
            
            const endTutorial = () => { localStorage.setItem(`ygo_tutorial_${tutorialState.key}_completed`, 'true'); setTutorialState({ active: false, steps: [], key: 'main' }); };
            
            const handleTutorialStepChange = (nextStepIndex) => {
                if (nextStepIndex === 2) { 
                    setIsSearchPanelOpen(false);
                }
            };
            
            const handleCardMouseEnter = (card) => { if (window.__YGO_DRAGGING__ === true || window.innerWidth <= 1024) return; setHoveredCard({ card }); };
            const handleCardMouseLeave = () => { if (window.__YGO_DRAGGING__ === true) return; setHoveredCard({ card: null }); };
            const handleCardMouseMove = () => { if (window.__YGO_DRAGGING__ === true || window.innerWidth <= 1024) return; };

            const addCardToPool = (apiCard) => {
                const newCard = createComboCardInstance(apiCard, IMAGE_PROXY);
                setComboState({ ...comboState, cardPool: [...cardPool, newCard] }, `Added '${newCard.name}'`);
                setJustAddedCardId(newCard.instanceId);
                setNotification({ show: true, message: t('notificationAdded') });
            };

            const handleSaveCustomCard = (customCard) => {
                const existingIndex = cardPool.findIndex(c => c.instanceId === customCard.instanceId);
                let newPool;
                let description;
                if (existingIndex > -1) {
                    newPool = [...cardPool];
                    newPool[existingIndex] = customCard;
                    description = `Updated custom card '${customCard.name}'`;
                } else {
                    newPool = [...cardPool, customCard];
                    description = `Created custom card '${customCard.name}'`;
                }
                setComboState({ ...comboState, cardPool: newPool }, description);
                setJustAddedCardId(customCard.instanceId);
            };

            const handleAddToken = () => { if (allTokens.length === 0) { console.error("Token list not loaded yet."); return; } const randomToken = allTokens[Math.floor(Math.random() * allTokens.length)]; addCardToPool(randomToken); };
            
            const removeCardFromPool = (instanceId) => {
                if (hoveredCard.card?.instanceId === instanceId) {
                    handleCardMouseLeave();
                }
                const cardToRemove = cardPool.find(c => c.instanceId === instanceId);
                if (!cardToRemove) return;
                const newPool = cardPool.filter(c => c.instanceId !== instanceId);
                const newHand = startingHand.map(group => group.filter(item => item.instanceId !== instanceId)).filter(group => group.length > 0);
                const newSteps = comboSteps.map(step => ({...step, targetCards: step.targetCards.filter(c => c.instanceId !== instanceId)})).filter(step => step.mainCardInstanceId !== instanceId);
                const newBoard = finalBoardCards.filter(item => item.card.instanceId !== instanceId);
                setComboState({ cardPool: newPool, startingHand: newHand.length > 0 ? newHand : [[]], comboSteps: newSteps, finalBoardCards: newBoard }, `Removed '${cardToRemove.name}'`);
                setToast({ show: true, message: t('toastRemoved'), onUndo: () => undo() });
            };

            const getDefaultAction = (cardType) => { if (!cardType) return "Normal Summon"; if (cardType.includes("Fusion") || cardType.includes("Synchro") || cardType.includes("Xyz") || cardType.includes("Link")) { return "Special Summon"; } if (cardType.includes("Spell") || cardType.includes("Trap")) { return "Activate Spell/Trap"; } return "Normal Summon"; };
            const addStep = (mainCard) => { const newStep = { type: "step", id: generateId(), mainCardInstanceId: mainCard.instanceId, actionType: getDefaultAction(mainCard.type), customActionText: '', actionDescription: '', targetCards: [], vulnerability: { text: '', cards: [] }, isLocked: false, location: null }; setComboState({ ...comboState, comboSteps: [...comboSteps, newStep] }, `Added step with '${mainCard.name}'`); };
            
            const handleAddStepOrNote = (item) => {
                const newItem = item.isNote
                    ? { type: 'note', id: generateId(), text: '' }
                    : { type: "step", id: generateId(), mainCardInstanceId: item.instanceId, actionType: getDefaultAction(item.type), customActionText: '', actionDescription: '', targetCards: [], vulnerability: { text: '', cards: [] }, isLocked: false, location: null };
                
                const newSteps = [...comboSteps, newItem];
                setComboState({ ...comboState, comboSteps: newSteps }, `Added ${item.isNote ? 'note' : 'step'}`);
            };

            const updateStep = (stepId, updatedData) => { const newSteps = comboSteps.map(step => step.id === stepId ? { ...step, ...updatedData } : step); setComboState({ ...comboState, comboSteps: newSteps }, `Updated step`); };
            const deleteStep = (stepId) => { const newSteps = comboSteps.filter(step => step.id !== stepId); setComboState({ ...comboState, comboSteps: newSteps }, `Deleted step`); };
            const removeTargetCardFromStep = (stepId, targetInstanceId) => { const newSteps = comboSteps.map(step => { if (step.id === stepId) { return { ...step, targetCards: step.targetCards.filter(card => card.instanceId !== targetInstanceId) }; } return step; }); setComboState({ ...comboState, comboSteps: newSteps }, `Removed target card from step`); };
            
            const addCardToFinalBoard = (card) => { if (finalBoardCards.some(item => item.card.instanceId === card.instanceId)) return; const newBoardItem = { id: generateId(), card: card, zone: YGO_ZONES[2], isDisruption: false }; setComboState({ ...comboState, finalBoardCards: [...finalBoardCards, newBoardItem] }, `Added '${card.name}' to board`); };
            
            const updateFinalBoardCard = (itemId, updatedData) => { const newBoard = finalBoardCards.map(item => item.id === itemId ? { ...item, ...updatedData } : item); setComboState({ ...comboState, finalBoardCards: newBoard }, `Updated board card`); };
            
            const removeCardFromFinalBoard = (id) => {
                const itemToRemove = finalBoardCards.find(item => item.id === id);
                if (itemToRemove && hoveredCard.card?.instanceId === itemToRemove.card.instanceId) {
                    handleCardMouseLeave();
                }
                const newBoard = finalBoardCards.filter(item => item.id !== id);
                setComboState({ ...comboState, finalBoardCards: newBoard }, `Removed board card`);
                setToast({ show: true, message: t('toastRemoved'), onUndo: () => undo() });
            };

            const clearAll = () => { setShowClearConfirmModal(false); loadState(initialComboState, "Cleared all"); localStorage.removeItem(AUTO_SAVE_KEY); };
            
            const handleConfirmExport = async () => {
                if (!(comboTitle || '').trim()) {
                    setNotification({ show: true, message: t('exportTitleRequired') });
                    setShowExportOptionsModal(false);
                    return;
                }
                setShowExportOptionsModal(false);
                setIsExportingPng(true);
                setExportMessage(t('fetchingImages'));
                setExportProgress(0);
                const allCardInstances = [ ...startingHand.flat().map(item => item.instanceId), ...comboSteps.flatMap(s => s.type === 'step' ? [s.mainCardInstanceId, ...s.targetCards.map(tc => tc.instanceId), ...(s.vulnerability?.cards.map(vc => vc.instanceId) || [])] : []), ...finalBoardCards.map(fb => fb.card.instanceId) ];
                const uniqueCardIds = [...new Set(allCardInstances)];
                const cardsToExport = uniqueCardIds.map(id => findCard(id)).filter(Boolean);
                const imageUrls = cardsToExport.flatMap(c => c.isCustom ? [c.image_url] : [c.image_url_small, c.image_url_cropped]).filter(Boolean);
                const uniqueImageUrls = [...new Set(imageUrls)];
                const imageMap = {};
                
                const loadImageAsDataURL = (url) => {
                    return new Promise((resolve, reject) => {
                        const timeoutId = setTimeout(() => reject(new Error(`Image load timed out for ${url}`)), 8000);
                        const img = new Image();
                        img.crossOrigin = 'Anonymous';
                        img.onload = () => {
                            clearTimeout(timeoutId);
                            try {
                                const canvas = document.createElement('canvas');
                                canvas.width = img.naturalWidth;
                                canvas.height = img.naturalHeight;
                                const ctx = canvas.getContext('2d');
                                ctx.drawImage(img, 0, 0);
                                resolve(canvas.toDataURL('image/png'));
                            } catch (e) {
                                reject(new Error(`Failed to convert image to data URL: ${url}`));
                            }
                        };
                        img.onerror = () => { clearTimeout(timeoutId); reject(new Error(`Failed to load image: ${url}`)); };
                        img.src = url;
                    });
                };

                try {
                    let loadedImages = 0;
                    const blankImage = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/5+AAgUBAQ8DFwAAAABJRU5ErkJggg==';
                    const promises = uniqueImageUrls.map((url) => {
                        if (url.startsWith('data:image')) {
                            imageMap[url] = url;
                            loadedImages++;
                            setExportProgress((loadedImages / uniqueImageUrls.length) * 50);
                            return Promise.resolve();
                        }
                        return loadImageAsDataURL(url)
                            .then((dataUrl) => { imageMap[url] = dataUrl; })
                            .catch((err) => { console.warn(err.message); imageMap[url] = blankImage; })
                            .finally(() => { loadedImages++; setExportProgress((loadedImages / uniqueImageUrls.length) * 50); });
                    });

                    await Promise.allSettled(promises);
                    
                    setExportMessage(t('generatingPng'));
                    const exportContainer = document.getElementById('export-container');
                    const exportRoot = createRoot(exportContainer);
                    exportRoot.render(<ExportLayout {...{ comboTitle, startingHand, comboSteps, finalBoardCards, notes, findCard, t, exportOptions, imageMap }} />);
                    
                    // --- New Robust Export Logic ---
                    // 1. Wait for React to render the component.
                    await new Promise(resolve => setTimeout(resolve, 100)); 
                    
                    // 2. Apply the special export styles.
                    document.body.setAttribute("data-exporting","1");

                    // 3. Wait for the browser to apply the new CSS.
                    await new Promise(resolve => setTimeout(resolve, 100)); 

                    // 4. CRITICAL: Wait for all fonts (including custom ones from CSS) to be fully loaded.
                    await document.fonts.ready;

                    // 5. Final safety delay for the browser to repaint everything with the correct fonts.
                    await new Promise(resolve => setTimeout(resolve, 200)); 

                    let adaptiveScale = exportOptions.scale;
                    const stepCountForScale = Array.isArray(comboSteps) ? comboSteps.filter(s => s?.type === 'step').length : 0;
                    if (stepCountForScale > 15) adaptiveScale = Math.min(adaptiveScale, 1.5);
                    else if (stepCountForScale > 8) adaptiveScale = Math.min(adaptiveScale, 2);
                    
                    setSmartExportBackground(exportContainer.querySelector('.export-onewm'));
                    const canvas = await html2canvas(exportContainer, { scale: adaptiveScale, useCORS: true, backgroundColor: null });

                    setExportProgress(100);
                    setPngPreviewUrl(canvas.toDataURL('image/png'));
                    exportRoot.unmount();
                } catch(err) {
                    console.error("Error exporting to PNG:", err);
                    setExportMessage(t('exportError'));
                } finally {
                    document.body.removeAttribute("data-exporting");
                    setIsExportingPng(false);
                }
            };

            const downloadPng = () => { const link = document.createElement('a'); link.download = `${comboTitle.replace(/[^a-z0-9]/gi, '_').toLowerCase() || 'yugioh_combo'}.png`; link.href = pngPreviewUrl; link.click(); setPngPreviewUrl(null); };
            const findCard = (instanceId) => cardPool.find(c => c.instanceId === instanceId);
            
            const addCardToStartingHand = (card, groupIndex = 0) => {
                if (!card) return;
                const newHands = comboState.startingHand.map((group, index) => {
                    if (index === groupIndex) {
                        if (!group.some(item => item.instanceId === card.instanceId)) {
                            return [...group, { instanceId: card.instanceId, quantity: 1 }];
                        }
                    }
                    return group;
                });
                if (JSON.stringify(newHands) !== JSON.stringify(comboState.startingHand)) {
                    setComboState({ ...comboState, startingHand: newHands }, `Added '${card.name}' to hand`);
                }
            };

            const removeCardFromHand = (instanceId, groupIndex) => {
                if (hoveredCard.card?.instanceId === instanceId) {
                    handleCardMouseLeave();
                }
                const newHands = startingHand.map((g, i) => i === groupIndex ? g.filter(it => it.instanceId !== instanceId) : g );
                setComboState({...comboState, startingHand: newHands}, 'Remove from hand');
                setToast({ show: true, message: t('toastRemoved'), onUndo: () => undo() });
            };

            const handleDragStart = (e, type, data) => { window.__YGO_DRAGGING__ = true; handleCardMouseLeave(); e.dataTransfer.setData('text/plain', JSON.stringify({type, data})); e.target.classList.add('dragging'); setDraggedItem({ type, data }); };
            const handleDragEnd = (e) => { window.__YGO_DRAGGING__ = false; if (e.target && e.target.classList) e.target.classList.remove('dragging'); setDraggedItem(null); setDragOverIndex(null); };
            
            const handleDrop = (e, targetArea, groupIndex) => {
                e.preventDefault();
                e.currentTarget.classList.remove('drag-over');
                const droppedData = JSON.parse(e.dataTransfer.getData('text/plain'));
                if (!droppedData) return;

                const processDrop = (cardToAdd) => {
                    if (cardToAdd) {
                        if (targetArea === 'startingHand') addCardToStartingHand(cardToAdd, groupIndex);
                        else if (targetArea === 'comboSteps') addStep(cardToAdd);
                        else if (targetArea === 'finalBoard') addCardToFinalBoard(cardToAdd);
                    }
                };
                
                if (['pool-card', 'hand-card', 'board-card'].includes(droppedData.type)) {
                    const cardToAdd = findCard(droppedData.data.instanceId || droppedData.data);
                    processDrop(cardToAdd);
                } else if (droppedData.type === 'search-card') {
                    const apiCard = droppedData.data;
                    let cardToAdd = cardPool.find(c => c.ygoprodeck_id === apiCard.id);
                    if (!cardToAdd) {
                        cardToAdd = createComboCardInstance(apiCard, IMAGE_PROXY);
                        const newPool = [...cardPool, cardToAdd];
                        const newState = { ...comboState, cardPool: newPool };
                        setComboState(newState, `Added '${cardToAdd.name}'`);
                        processDrop(cardToAdd);
                    } else {
                        processDrop(cardToAdd);
                    }
                }
                setDraggedItem(null);
            };

            const handleReorder = (type, draggedItem, targetItem) => {
                if (type === 'hand') {
                    const newHands = [...startingHand];
                    const sourceGroup = [...newHands[draggedItem.groupIndex]];
                    const targetGroup = draggedItem.groupIndex === targetItem.groupIndex ? sourceGroup : [...newHands[targetItem.groupIndex]];
                    const draggedIndex = sourceGroup.findIndex(c => c.instanceId === draggedItem.instanceId);
                    if (draggedIndex === -1) return;
                    const [removed] = sourceGroup.splice(draggedIndex, 1);
                    const targetIndex = targetGroup.findIndex(c => c.instanceId === targetItem.instanceId);
                    targetGroup.splice(targetIndex, 0, removed);
                    newHands[draggedItem.groupIndex] = sourceGroup;
                    newHands[targetItem.groupIndex] = targetGroup;
                    setComboState({ ...comboState, startingHand: newHands }, 'Reordered hand');
                } else if (type === 'board') {
                    let list = [...finalBoardCards];
                    const draggedIndex = list.findIndex(c => c.id === draggedItem.id);
                    if (draggedIndex === -1) return;
                    const [removed] = list.splice(draggedIndex, 1);
                    const targetIndex = list.findIndex(c => c.id === targetItem.id);
                    list.splice(targetIndex, 0, removed);
                    setComboState({ ...comboState, finalBoardCards: list }, 'Reordered board');
                } else if (type === 'step') {
                    let list = [...comboSteps];
                    const draggedIndex = list.findIndex(s => s.id === draggedItem.id);
                    if (draggedIndex === -1) return;
                    const [removed] = list.splice(draggedIndex, 1);
                    const targetIndex = list.findIndex(s => s.id === targetItem.id);
                    list.splice(targetIndex, 0, removed);
                    setComboState({ ...comboState, comboSteps: list }, 'Reordered combo steps');
                }
            };
            
            const handleContextMenu = (card, e, context) => {
                handleCardMouseLeave();
                let options = [ { label: t('ctxViewCard'), action: () => setSelectedCardForZoom(card) } ];
                if (context === 'pool') {
                    if (card.isCustom) {
                        options.push({ label: t('ctxEditCustomCard'), action: () => { setEditingCustomCard(card); setShowCustomCardModal(true); } });
                    }
                    options.push({ label: t('ctxRemoveFromPool'), action: () => removeCardFromPool(card.instanceId) });
                }
                options.push(
                    { label: t('ctxAddToHand'), action: () => addCardToStartingHand(card, 0) },
                    { label: t('ctxAddStep'), action: () => addStep(card) },
                    { label: t('ctxAddFinalBoard'), action: () => addCardToFinalBoard(card) }
                );
                setContextMenu({ card, x: e.clientX, y: e.clientY, options });
            };

            const closeContextMenu = () => setContextMenu({ card: null, x: 0, y: 0, options: [] });
            const filteredSearchResults = useMemo(() => { if (!searchResults) return null; const poolIds = new Set(cardPool.map(c => c.ygoprodeck_id)); return searchResults.filter(c => !poolIds.has(c.id)); }, [searchResults, cardPool]);
            const paginatedResults = useMemo(() => { if (!filteredSearchResults) return []; const startIndex = (currentPage - 1) * CARDS_PER_PAGE; return filteredSearchResults.slice(startIndex, startIndex + CARDS_PER_PAGE); }, [currentPage, filteredSearchResults]);
            const totalPages = filteredSearchResults ? Math.ceil(filteredSearchResults.length / CARDS_PER_PAGE) : 0;
            
            const handleSaveCombo = async (name) => { 
                if (!name) return; 
                if (isOnlineSaveEnabled && user) {
                    try {
                        const comboData = {
                            ...comboState,
                            authorId: user.uid,
                            createdAt: firebase.firestore.FieldValue.serverTimestamp()
                        };
                        const combosCol = db.collection('artifacts').doc(appId).collection('public').doc('data').collection('combos');
                        await combosCol.doc(name).set(comboData);
                        setShowSaveModal(false);
                        localStorage.removeItem(AUTO_SAVE_KEY);
                        setNotification({ show: true, message: '¡Combo guardado en la nube!' });
                    } catch (e) { console.error("Error saving combo to Firestore:", e); alert(t('saveError')); }
                } else {
                    try { const serializedState = JSON.stringify(comboState); localStorage.setItem(`${LOCAL_STORAGE_PREFIX}${name}`, serializedState); setShowSaveModal(false); localStorage.removeItem(AUTO_SAVE_KEY); } catch (e) { console.error("Error saving combo locally:", e); alert(t('saveError')); }
                }
            };
            
            const handleLoadCombo = async (name) => {
                if (isOnlineSaveEnabled && user) {
                    try {
                        const docRef = db.collection('artifacts').doc(appId).collection('public').doc('data').collection('combos').doc(name);
                        const docSnap = await docRef.get();
                        if (docSnap.exists()) {
                            loadState(docSnap.data(), `Loaded '${name}' from cloud`);
                        }
                        setShowLoadModal(false);
                    } catch (e) { console.error("Error loading combo from Firestore:", e); alert(t('loadError')); }
                } else {
                    try { const serializedState = localStorage.getItem(`${LOCAL_STORAGE_PREFIX}${name}`); if (serializedState) { const loaded = JSON.parse(serializedState); loadState(loaded, `Loaded '${name}'`); } setShowLoadModal(false); } catch (e) { console.error("Error loading combo locally:", e); alert(t('loadError')); }
                }
            };
            
            const handleDeleteCombo = async (name) => {
                 if (isOnlineSaveEnabled && user) {
                    try {
                        const docRef = db.collection('artifacts').doc(appId).collection('public').doc('data').collection('combos').doc(name);
                        // Optional: Check for authorId before deleting for extra security
                        const doc = await docRef.get();
                        if (doc.exists && doc.data().authorId === user.uid) {
                            await docRef.delete();
                        } else {
                            alert("No tienes permiso para borrar este combo.");
                        }
                    } catch (e) { console.error("Error deleting combo from Firestore:", e); }
                } else {
                    try { localStorage.removeItem(`${LOCAL_STORAGE_PREFIX}${name}`); } catch (e) { console.error("Error deleting combo locally:", e); } 
                }
            };
            
            const getShareUrl = () => {
                try {
                    const jsonString = JSON.stringify(comboState);
                    const compressed = pako.deflate(jsonString, { to: 'string' });
                    const encoded = btoa(compressed);
                    return `${window.location.origin}${window.location.pathname}?combo=${encoded}`;
                } catch (e) {
                    console.error("Error creating share link:", e);
                    return window.location.href;
                }
            };

            const handleShareUrl = () => {
                const url = getShareUrl();
                navigator.clipboard.writeText(url).then(() => {
                    setNotification({ show: true, message: t('linkCopied') });
                });
            };

            const handleTouchStart = (e, type, data) => {
                const touch = e.touches[0];
                const rect = e.currentTarget.getBoundingClientRect();
                setTouchDragGhost({
                    content: e.currentTarget.innerHTML,
                    width: rect.width,
                    height: rect.height,
                    x: touch.clientX,
                    y: touch.clientY,
                    offsetX: touch.clientX - rect.left,
                    offsetY: touch.clientY - rect.top,
                    type,
                    data
                });
                e.currentTarget.classList.add('dragging');
            };

            const handleTouchMove = (e) => {
                if (!touchDragGhost) return;
                const touch = e.touches[0];
                setTouchDragGhost(prev => ({...prev, x: touch.clientX, y: touch.clientY}));
                
                document.querySelectorAll('.drop-zone').forEach(el => el.classList.remove('drag-over'));
                const elementUnder = document.elementFromPoint(touch.clientX, touch.clientY);
                const dropZone = elementUnder?.closest('.drop-zone');
                if(dropZone) {
                    dropZone.classList.add('drag-over');
                }
            };

            const handleTouchEnd = (e) => {
                if (!touchDragGhost) return;
                const touch = e.changedTouches[0];
                const elementUnder = document.elementFromPoint(touch.clientX, touch.clientY);
                const dropZone = elementUnder?.closest('.drop-zone');
                
                if (dropZone) {
                    dropZone.classList.remove('drag-over');
                    const targetArea = dropZone.dataset.dropArea;
                    const groupIndex = parseInt(dropZone.dataset.groupIndex, 10);
                    
                    const processDrop = (cardToAdd) => {
                        if (cardToAdd) {
                            if (targetArea === 'startingHand') addCardToStartingHand(cardToAdd, groupIndex);
                            else if (targetArea === 'comboSteps') addStep(cardToAdd);
                            else if (targetArea === 'finalBoard') addCardToFinalBoard(cardToAdd);
                        }
                    };

                    if (['pool-card', 'hand-card', 'board-card'].includes(touchDragGhost.type)) {
                        const cardToAdd = findCard(touchDragGhost.data.instanceId || touchDragGhost.data);
                        processDrop(cardToAdd);
                    } else if (touchDragGhost.type === 'search-card') {
                         const apiCard = touchDragGhost.data;
                         let cardToAdd = cardPool.find(c => c.ygoprodeck_id === apiCard.id);
                         if (!cardToAdd) {
                            cardToAdd = createComboCardInstance(apiCard, IMAGE_PROXY);
                            const newPool = [...cardPool, cardToAdd];
                            setComboState({...comboState, cardPool: newPool}, `Added '${cardToAdd.name}'`);
                            processDrop(cardToAdd);
                         } else {
                            processDrop(cardToAdd);
                         }
                    }
                }
                
                setTouchDragGhost(null);
                document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));
            };
            
            const disruptionCount = finalBoardCards.filter(c => c.isDisruption).length;
            
            const toggleStepLock = (stepId) => {
                const newSteps = comboSteps.map(step => 
                    step.id === stepId ? { ...step, isLocked: !step.isLocked } : step
                );
                setComboState({ ...comboState, comboSteps: newSteps }, 'Toggled step lock');
            };

            const handleConfirmDeleteFrom = () => {
                if (deleteFromIndex === null) return;
                const newSteps = comboSteps.slice(0, deleteFromIndex);
                setComboState({ ...comboState, comboSteps: newSteps }, `Deleted steps from index ${deleteFromIndex}`);
                setDeleteFromIndex(null);
            };
    
            const [theme, setTheme] = useState('dark');
            useEffect(() => {
                const savedTheme = localStorage.getItem('ygo-theme') || 'dark';
                setTheme(savedTheme);
                document.documentElement.setAttribute('data-theme', savedTheme);
            }, []);

            const toggleTheme = () => {
                const newTheme = theme === 'light' ? 'dark' : 'light';
                setTheme(newTheme);
                localStorage.setItem('ygo-theme', newTheme);
                document.documentElement.setAttribute('data-theme', newTheme);
            };
            
            const actualSteps = useMemo(() => comboSteps.filter(s => s.type === 'step'), [comboSteps]);
            const comboStats = useMemo(() => {
                const stats = { types: { Monster: 0, Spell: 0, Trap: 0 }, attributes: { DARK: 0, LIGHT: 0, WIND: 0, WATER: 0, FIRE: 0, EARTH: 0, DIVINE: 0 } };
                const seenCards = new Set();
                actualSteps.forEach(step => {
                    const card = findCard(step.mainCardInstanceId);
                    if (card && !seenCards.has(card.name)) {
                        seenCards.add(card.name);
                        if (card.type) {
                            if (card.type.includes('Monster')) stats.types.Monster++;
                            else if (card.type.includes('Spell')) stats.types.Spell++;
                            else if (card.type.includes('Trap')) stats.types.Trap++;
                        }
                        if (card.attribute && stats.attributes.hasOwnProperty(card.attribute)) {
                            stats.attributes[card.attribute]++;
                        }
                    }
                });
                return seenCards.size > 0 ? stats : null;
            }, [actualSteps, cardPool]);

            if (isLoading) {
                return (
                    <React.Fragment>
                        <StarfieldBackground />
                        <div id="splash-screen">
                           <h1 className="font-yugi-title text-4xl md:text-6xl text-amber-300">Yu-Gi-Oh! Combo Maker</h1>
                        </div>
                    </React.Fragment>
                );
            }

            return (
                <React.Fragment>
                    <StarfieldBackground />
                    <div className={`relative min-h-screen`} onTouchMove={handleTouchMove} onTouchEnd={handleTouchEnd}>
                        <Notification message={notification.message} show={notification.show} t={t} />
                        {toast.show && <Toast message={toast.message} onUndo={toast.onUndo} onClose={() => setToast({ show: false, message: '', onUndo: null })} t={t} />}
                        {showRestoreNotification && <RestoreNotification onRestore={handleRestore} onDismiss={() => setShowRestoreNotification(false)} t={t} />}
                        {tutorialState.active && <Tutorial steps={tutorialState.steps} onEnd={endTutorial} t={t} onStepChange={handleTutorialStepChange} />}
                        <CardHoverPreview card={hoveredCard.card} />
                        {touchDragGhost && createPortal(
                            <div id="touch-drag-ghost" style={{ top: touchDragGhost.y - touchDragGhost.offsetY, left: touchDragGhost.x - touchDragGhost.offsetX, width: touchDragGhost.width, height: touchDragGhost.height }} dangerouslySetInnerHTML={{ __html: touchDragGhost.content }}></div>,
                            document.getElementById('touch-drag-ghost-container')
                        )}

                        {!isApiReady && (<div className="fixed inset-0 bg-black bg-opacity-80 flex flex-col items-center justify-center z-50"><Spinner /><p className="text-lg text-violet-300 mt-4">{apiCheckMessage}</p></div>)}
                        <CardZoomModal card={selectedCardForZoom} onClose={() => setSelectedCardForZoom(null)} t={t} onSaveNotes={(cardId, newNotes) => { const newPool = cardPool.map(c => c.instanceId === cardId ? {...c, notes: newNotes} : c); setComboState({...comboState, cardPool: newPool}, `Updated notes for card`); }}/>
                        <ConfirmationModal show={showClearConfirmModal} title={t('clearConfirmTitle')} message={t('clearConfirmMessage')} onConfirm={clearAll} onCancel={() => setShowClearConfirmModal(false)} t={t} />
                        <ConfirmationModal show={deleteFromIndex !== null} title={t('undoFromHereConfirmTitle')} message={t('undoFromHereConfirmMessage', { stepNumber: deleteFromIndex + 1 })} onConfirm={handleConfirmDeleteFrom} onCancel={() => setDeleteFromIndex(null)} t={t} />
                        <ZonePickerModal show={zonePickerStepId !== null} onClose={() => setZonePickerStepId(null)} onSelect={(zone) => updateStep(zonePickerStepId, { location: zone })} t={t} />

                        <PngPreviewModal imageUrl={pngPreviewUrl} onDownload={downloadPng} onClose={() => setPngPreviewUrl(null)} t={t} shareUrl={getShareUrl()} comboTitle={comboTitle} />
                        <ExportOptionsModal show={showExportOptionsModal} onClose={() => setShowExportOptionsModal(false)} onConfirm={handleConfirmExport} exportOptions={exportOptions} setExportOptions={setExportOptions} t={t} />
                        <SaveComboModal show={showSaveModal} onClose={() => setShowSaveModal(false)} onSave={handleSaveCombo} t={t} isOnlineSaveEnabled={isOnlineSaveEnabled} />
                        <LoadComboModal show={showLoadModal} onClose={() => setShowLoadModal(false)} onSelect={handleLoadCombo} onDelete={handleDeleteCombo} t={t} db={db} user={user} appId={appId} isOnlineSaveEnabled={isOnlineSaveEnabled}/>
                        <CustomCardModal show={showCustomCardModal} onClose={() => { setShowCustomCardModal(false); setEditingCustomCard(null); }} onSave={handleSaveCustomCard} t={t} existingCard={editingCustomCard} />

                        {isExportingPng && <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4"><div className="bg-slate-800 rounded-lg shadow-xl p-8 text-center"><h3 className="text-xl font-bold mb-4 text-violet-300">{exportMessage}</h3><div className="w-full bg-slate-600 rounded-full h-4"><div className="bg-violet-500 h-4 rounded-full" style={{ width: `${exportProgress}%` }}></div></div><p className="text-white mt-2">{Math.round(exportProgress)}%</p></div></div>}
                        {contextMenu.card && <div className="fixed inset-0 z-50" onClick={closeContextMenu} onContextMenu={e => { e.preventDefault(); closeContextMenu(); }}><div style={{ position: 'fixed', top: `${contextMenu.y}px`, left: `${contextMenu.x}px` }} className="bg-slate-800 border border-slate-600 rounded-md shadow-lg py-2 w-48">{contextMenu.options.map(option => (<button key={option.label} onClick={() => { option.action(); closeContextMenu(); }} className="w-full text-left px-4 py-2 text-sm text-gray-200 hover:bg-violet-600">{option.label}</button>))}</div></div>}

                        <button onClick={() => setIsSearchPanelOpen(true)} className={`fixed top-1/2 -translate-y-1/2 left-0 z-30 bg-violet-700/80 backdrop-blur-sm text-white p-2 rounded-r-lg shadow-lg transition-all duration-300 hover:bg-violet-600 ${isSearchPanelOpen ? 'opacity-0 -translate-x-full' : 'opacity-100 translate-x-0'}`} aria-label="Abrir Búsqueda" data-tooltip="Abrir Búsqueda"><i className="fas fa-search"></i></button>

                        {isFlyoutButtonVisible && !isFlyoutPoolOpen && (
                            <button onClick={() => setIsFlyoutPoolOpen(true)} className="fixed top-1/2 -translate-y-1/2 right-0 z-30 bg-amber-600/80 backdrop-blur-sm text-white p-2 rounded-l-lg shadow-lg transition-all duration-300 hover:bg-amber-500" aria-label={t('cardPoolTitle')} data-tooltip={t('cardPoolTitle')}>
                                <i className="fas fa-layer-group"></i>
                            </button>
                        )}
                        
                        <aside className={`fixed top-0 right-0 w-full max-w-sm h-full bg-amber-900/90 backdrop-blur-sm p-4 border-l border-amber-700/50 z-40 transition-transform duration-300 flex flex-col ${isFlyoutPoolOpen ? 'translate-x-0' : 'translate-x-full'}`}>
                            <header className="flex justify-between items-center mb-4">
                                <h3 className="text-xl font-semibold text-amber-300">{t('cardPoolTitle')}</h3>
                                <button onClick={() => setIsFlyoutPoolOpen(false)} className="text-amber-200 hover:text-white" aria-label="Cerrar" data-tooltip="Cerrar"><i className="fas fa-times"></i></button>
                            </header>
                            <div className="flex-grow overflow-y-auto bg-black/20 p-2 rounded-lg">
                                {cardPool.length > 0 ? (
                                    <div className="grid gap-3 grid-cols-[repeat(auto-fill,minmax(6.5rem,1fr))]">
                                        {cardPool.map((card) => <CardDisplay key={card.instanceId} card={card} size="small" onClick={(c) => setSelectedCardForZoom(c)} onRemove={() => removeCardFromPool(card.instanceId)} onEdit={() => { setEditingCustomCard(card); setShowCustomCardModal(true); }} draggable={true} onDragStart={(e) => handleDragStart(e, 'pool-card', card)} onTouchStart={(e) => handleTouchStart(e, 'pool-card', card)} onDragEnd={handleDragEnd} onContextMenu={(c, e) => handleContextMenu(c, e, 'pool')} isHighlighted={highlightedCardIds.includes(card.instanceId)} isNew={card.instanceId === justAddedCardId} onMouseEnter={handleCardMouseEnter} onMouseLeave={handleCardMouseLeave} onMouseMove={handleCardMouseMove} />)}
                                    </div>
                                ) : (
                                    <EmptyState icon="fa-layer-group" title={t('emptyPoolTitle')} message={t('emptyPoolMessage')} />
                                )}
                            </div>
                        </aside>

                        <aside id="search-panel" className={`fixed top-0 left-0 w-full max-w-sm h-full bg-[var(--color-surface)]/80 backdrop-blur-sm p-4 border-r border-[var(--color-border)]/50 z-40 transition-transform duration-300 flex flex-col ${isSearchPanelOpen ? 'translate-x-0' : '-translate-x-full'}`}>
                            <header className="text-center mb-4 relative">
                                <h1 className="text-3xl font-bold text-[var(--color-secondary)] font-yugioh">{t('mainTitle')}</h1>
                                <button onClick={() => setIsSearchPanelOpen(false)} className="absolute top-0 right-0 text-[var(--color-text-muted)] hover:text-[var(--color-text)]" aria-label="Cerrar" data-tooltip="Cerrar"><i className="fas fa-times"></i></button>
                                <div className="absolute top-0 left-0" ref={langMenuRef}><button onClick={() => setIsLangMenuOpen(prev => !prev)} className="p-2 bg-[var(--color-surface-light)]/50 rounded-full hover:bg-[var(--color-surface-light)]"><i className="fas fa-globe"></i></button>{isLangMenuOpen && (<div className="absolute left-0 mt-2 w-36 bg-[var(--color-surface)] border border-[var(--color-border)] rounded-md shadow-lg py-1 z-50"><button onClick={() => { setLanguage('es'); setIsLangMenuOpen(false); }} className="flex items-center gap-2 w-full px-4 py-2 text-sm text-[var(--color-text)] hover:bg-[var(--color-primary)]"><span>🇪🇸</span> Español</button><button onClick={() => { setLanguage('en'); setIsLangMenuOpen(false); }} className="flex items-center gap-2 w-full px-4 py-2 text-sm text-[var(--color-text)] hover:bg-[var(--color-primary)]"><span>🇺🇸</span> English</button></div>)}</div>
                            </header>
                            <div className="relative mb-2">
                                <form onSubmit={(e) => { e.preventDefault(); handleSearchSubmit(searchTerm); }}>
                                    <input type="text" placeholder={t('searchPlaceholder')} value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} className="w-full p-3 bg-[var(--color-surface-light)] border border-[var(--color-border)] rounded-lg focus:ring-2 focus:ring-[var(--color-primary)] focus:outline-none pr-10" disabled={!isApiReady} />
                                </form>
                                {suggestions.length > 0 && (
                                    <div className="absolute top-full left-0 right-0 bg-[var(--color-surface)] border border-[var(--color-border)] rounded-b-lg z-50 max-h-60 overflow-y-auto">
                                        {suggestions.map(card => (
                                            <div key={card.id} onClick={() => handleSearchSubmit(card.name)} className="p-2 hover:bg-[var(--color-surface-light)] cursor-pointer text-sm">
                                                {card.name}
                                            </div>
                                        ))}
                                    </div>
                                )}
                                <button onClick={() => setShowFilters(prev => !prev)} className="absolute right-3 top-1/2 -translate-y-1/2 text-[var(--color-text-muted)] hover:text-[var(--color-text)]"><i className="fas fa-filter"></i></button>
                            </div>
                            {showFilters && (<div className="mb-4 p-3 bg-black/20 rounded-lg grid grid-cols-2 gap-2"><select value={filters.archetype} onChange={e => setFilters({...filters, archetype: e.target.value})} className="w-full p-1 bg-[var(--color-surface-light)] border border-[var(--color-border)] rounded-md text-xs"><option value="">{t('filterArchetype')}</option>{archetypes.map(a => <option key={a} value={a}>{a}</option>)}</select><select value={filters.type} onChange={e => setFilters({...filters, type: e.target.value})} className="w-full p-1 bg-[var(--color-surface-light)] border border-[var(--color-border)] rounded-md text-xs"><option value="">{t('filterType')}</option>{CARD_TYPES.map(t => <option key={t} value={t}>{t}</option>)}</select><select value={filters.attribute} onChange={e => setFilters({...filters, attribute: e.target.value})} className="w-full p-1 bg-[var(--color-surface-light)] border border-[var(--color-border)] rounded-md text-xs"><option value="">{t('filterAttribute')}</option>{ATTRIBUTES.map(a => <option key={a} value={a}>{a}</option>)}</select><select value={filters.level} onChange={e => setFilters({...filters, level: e.target.value})} className="w-full p-1 bg-[var(--color-surface-light)] border border-[var(--color-border)] rounded-md text-xs"><option value="">{t('filterLevel')}</option>{LEVELS.map(l => <option key={l} value={l}>{l}</option>)}</select><button onClick={() => { setFilters({ type: '', attribute: '', level: '', archetype: '' }); debouncedSearch(searchTerm, { type: '', attribute: '', level: '', archetype: '' }, false); }} className="btn col-span-2 mt-1 px-2 py-1 bg-red-600 text-white text-xs font-semibold rounded-lg hover:bg-red-700">{t('clearFilters')}</button></div>)}
                            <PopularCardsCarousel onCardClick={addCardToPool} t={t} cardPool={cardPool} />
                            <div className="flex-grow overflow-y-auto bg-black/20 p-2 rounded-lg">
                                {isLoadingSearch ? (
                                    <div className="grid grid-cols-3 gap-3">
                                        {Array.from({ length: 9 }).map((_, i) => <div key={i} className="w-full card-skeleton" style={{ aspectRatio: '0.686' }}></div>)}
                                    </div>
                                ) : paginatedResults.length > 0 ? (
                                    <div className="grid grid-cols-3 gap-3">
                                        {paginatedResults.map((apiCard, index) => {
                                            const cardInstance = createComboCardInstance(apiCard, IMAGE_PROXY);
                                            return <div key={apiCard.id} className="animate-fadeInUp" style={{animationDelay: `${index * 50}ms`}}><CardDisplay card={cardInstance} onClick={() => addCardToPool(apiCard)} draggable={true} onDragStart={(e) => handleDragStart(e, 'search-card', apiCard)} onTouchStart={(e) => handleTouchStart(e, 'search-card', apiCard)} onDragEnd={handleDragEnd} size="small" t={t} onContextMenu={(c, e) => handleContextMenu(cardInstance, e, 'search')} onMouseEnter={handleCardMouseEnter} onMouseLeave={handleCardMouseLeave} onMouseMove={handleCardMouseMove} /></div>
                                        })}
                                    </div>
                                ) : (searchTerm || Object.values(filters).some(v => v)) && <div className="p-4 text-center text-[var(--color-text-muted)]">{t('noCardsFound')}</div>
                                }
                            </div>
                            {totalPages > 1 && (<div className="flex justify-center items-center gap-2 mt-2 text-sm"><button onClick={() => setCurrentPage(p => p - 1)} disabled={currentPage === 1} className="btn px-3 py-1 bg-slate-600 rounded hover:bg-slate-500 disabled:opacity-50">‹</button><span>{t('page')} {currentPage} / {totalPages}</span><button onClick={() => setCurrentPage(p => p + 1)} disabled={currentPage === totalPages} className="btn px-3 py-1 bg-slate-600 rounded hover:bg-slate-500 disabled:opacity-50">›</button></div>)}
                        </aside>

                        <main className={`transition-all duration-300 p-4 lg:p-6 ${isSearchPanelOpen ? 'lg:ml-96' : 'ml-0'}`}>
                            <div className="flex flex-col h-full">
                                <header className="flex flex-col md:flex-row items-center gap-4 mb-2">
                                    <input type="text" value={comboTitle} onChange={(e) => setComboState({...comboState, comboTitle: sanitizeHTML(e.target.value)}, "Changed title")} className="w-full md:w-auto flex-grow p-2 text-3xl font-bold bg-transparent text-[var(--color-secondary)] placeholder-[var(--color-text-muted)] focus:bg-[var(--color-surface)]/50 rounded-lg outline-none font-yugioh" placeholder={t('comboTitlePlaceholder')} />
                                    <div className="flex items-center gap-2 flex-shrink-0 main-actions">
                                        <button onClick={toggleTheme} data-tooltip="Toggle Theme" className="btn p-3 bg-[var(--color-surface)] rounded-md hover:bg-[var(--color-surface-light)]"><i className={`fas ${theme === 'dark' ? 'fa-sun' : 'fa-moon'}`}></i></button>
                                        <button onClick={() => setTutorialState({ active: true, steps: tutorialSteps.main, key: 'main' })} data-tooltip="Ayuda" className="btn p-3 bg-[var(--color-surface)] rounded-md hover:bg-[var(--color-surface-light)]"><i className="fas fa-question-circle"></i></button>
                                        <button onClick={undo} disabled={!canUndo} data-tooltip={`${t('undo')} (Ctrl+Z)`} className="btn p-3 bg-[var(--color-surface)] rounded-md hover:bg-[var(--color-surface-light)] disabled:opacity-50"><i className="fas fa-undo"></i></button>
                                        <button onClick={redo} disabled={!canRedo} data-tooltip={`${t('redo')} (Ctrl+Y)`} className="btn p-3 bg-[var(--color-surface)] rounded-md hover:bg-[var(--color-surface-light)] disabled:opacity-50"><i className="fas fa-redo"></i></button>
                                        <button onClick={handleShareUrl} data-tooltip={t('shareUrl')} className="btn p-3 bg-purple-600 text-white rounded-md hover:bg-purple-700"><i className="fas fa-link"></i></button>
                                        <button onClick={() => setShowSaveModal(true)} data-tooltip={isOnlineSaveEnabled ? t('saveOnlineTooltip') : t('saveLocalTooltip')} className="btn p-3 bg-blue-600 rounded-md hover:bg-blue-700 flex items-center gap-2"><i className="fas fa-save"></i> {isOnlineSaveEnabled && <i className="fas fa-cloud text-xs"></i>}</button>
                                        <button onClick={() => setShowLoadModal(true)} data-tooltip={t('publicCombosTitle')} className="btn p-3 bg-blue-600 rounded-md hover:bg-blue-700"><i className="fas fa-folder-open"></i></button>
                                        <button onClick={() => setShowExportOptionsModal(true)} disabled={isExportingPng} data-tooltip={t('exportPng')} className="btn p-3 bg-green-600 rounded-md hover:bg-green-700 disabled:opacity-50 flex items-center gap-2">{isExportingPng ? <Spinner /> : <i className="fas fa-download"></i>} <span className="hidden xl:inline">{t('exportPng')}</span></button>
                                        <button onClick={() => setShowClearConfirmModal(true)} data-tooltip={t('clearAll')} className="btn p-3 bg-red-600 rounded-md hover:bg-red-700"><i className="fas fa-trash"></i></button>
                                    </div>
                                </header>
                                <div className="w-full text-center text-xs text-slate-400 mb-4 h-4">
                                    {isOnlineSaveEnabled ? (user ? `${t('loggedInAs')} ${user.uid}` : t('connecting')) : 'Guardado local activado'}
                                </div>
                                <div className="flex-grow space-y-6">
                                    <section id="card-pool-section" ref={cardPoolSectionRef} className="bg-[var(--color-surface)]/30 rounded-lg border border-[var(--color-border)]/30 card-pool">
                                        <h3 onClick={() => setIsCardPoolOpen(!isCardPoolOpen)} className="text-xl font-semibold text-[var(--color-secondary)] p-4 flex justify-between items-center cursor-pointer hover:bg-[var(--color-surface)]/50 transition-colors">
                                            <span className="flex items-center gap-4">{t('cardPoolTitle')}
                                                <button onClick={(e) => { e.stopPropagation(); setShowCustomCardModal(true); }} className="btn px-3 py-1 text-sm bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700">{t('createCustomCard')}</button>
                                                <button onClick={(e) => { e.stopPropagation(); handleAddToken(); }} disabled={allTokens.length === 0 || isAddingToken} className="btn px-3 py-1 text-sm bg-violet-600 text-white font-semibold rounded-lg hover:bg-violet-700 disabled:opacity-50 flex items-center gap-2">{isAddingToken && <Spinner />} {t('addToken')}</button>
                                            </span>
                                            <i className={`fas fa-chevron-down transition-transform duration-300 ${isCardPoolOpen ? '' : '-rotate-90'}`}></i>
                                        </h3>
                                        <div className={`transition-[max-height] duration-500 ease-in-out overflow-hidden ${isCardPoolOpen ? 'max-h-[40rem]' : 'max-h-0'}`}>
                                            <div className="p-4 pt-0">
                                                <div className="p-4 bg-black/20 rounded-lg min-h-[11rem] relative">
                                                    {cardPool.length > 0 ? (
                                                        <div className="grid gap-3 grid-cols-[repeat(auto-fill,minmax(6.5rem,1fr))]">
                                                            {cardPool.map((card) => <CardDisplay key={card.instanceId} card={card} size="small" onClick={(c) => setSelectedCardForZoom(c)} onRemove={() => removeCardFromPool(card.instanceId)} onEdit={() => { setEditingCustomCard(card); setShowCustomCardModal(true); }} draggable={true} onDragStart={(e) => handleDragStart(e, 'pool-card', card)} onTouchStart={(e) => handleTouchStart(e, 'pool-card', card)} onDragEnd={handleDragEnd} onContextMenu={(c, e) => handleContextMenu(c, e, 'pool')} isHighlighted={highlightedCardIds.includes(card.instanceId)} isNew={card.instanceId === justAddedCardId} onMouseEnter={handleCardMouseEnter} onMouseLeave={handleCardMouseLeave} onMouseMove={handleCardMouseMove} />)}
                                                        </div>
                                                    ) : (
                                                        <EmptyState icon="fa-layer-group" title={t('emptyPoolTitle')} message={t('emptyPoolMessage')} />
                                                    )}
                                                </div>
                                            </div>
                                        </div>
                                    </section>
                                    <section className="bg-[var(--color-surface)]/30 rounded-lg border border-[var(--color-border)]/30">
                                        <h3 onClick={() => setIsStatsOpen(!isStatsOpen)} className="text-xl font-semibold text-[var(--color-secondary)] p-4 flex justify-between items-center cursor-pointer hover:bg-[var(--color-surface)]/50 transition-colors">
                                            <span>{t('comboStatsTitle')}</span>
                                            <i className={`fas fa-chevron-down transition-transform duration-300 ${isStatsOpen ? '' : '-rotate-90'}`}></i>
                                        </h3>
                                        <div className={`transition-[max-height] duration-500 ease-in-out overflow-hidden ${isStatsOpen ? 'max-h-[40rem]' : 'max-h-0'}`}>
                                            <ComboStats stats={comboStats} t={t} />
                                        </div>
                                    </section>
                                    <section id="starting-hand-section" className="bg-[var(--color-surface)]/30 rounded-lg border border-[var(--color-border)]/30 starting-hand">
                                        <h3 onClick={() => setIsStartingHandOpen(!isStartingHandOpen)} className="text-xl font-semibold text-[var(--color-secondary)] p-4 flex justify-between items-center cursor-pointer hover:bg-[var(--color-surface)]/50 transition-colors">
                                            <span className="flex items-center">{t('startingHandTitle')} <span data-tooltip={t('helpStartingHand')}><i className="fas fa-question-circle ml-2"></i></span></span>
                                            <i className={`fas fa-chevron-down transition-transform duration-300 ${isStartingHandOpen ? '' : '-rotate-90'}`}></i>
                                        </h3>
                                        <div className={`transition-[max-height] duration-500 ease-in-out overflow-hidden ${isStartingHandOpen ? 'max-h-[40rem]' : 'max-h-0'}`}>
                                            <div className="p-4 pt-0">
                                                <div className="flex flex-row items-start gap-4 pb-4 overflow-x-auto">
                                                    {startingHand.map((group, groupIndex) => (
                                                        <React.Fragment key={groupIndex}>
                                                            <div className="relative flex-shrink-0">
                                                                {startingHand.length > 1 && (<button onClick={() => { const newHands = startingHand.filter((_, i) => i !== groupIndex); setComboState({...comboState, startingHand: newHands}, 'Removed alternate hand'); }} className="absolute -top-2 -right-2 w-6 h-6 bg-red-600 text-white rounded-full flex items-center justify-center text-xs font-bold hover:bg-red-700 z-10">X</button>)}
                                                                <div data-drop-area="startingHand" data-group-index={groupIndex} onDragOver={(e) => {e.preventDefault(); e.currentTarget.classList.add('drag-over')}} onDragLeave={(e) => e.currentTarget.classList.remove('drag-over')} onDrop={(e) => handleDrop(e, 'startingHand', groupIndex)} className="drop-zone p-4 bg-black/20 rounded-lg min-h-[11rem] flex flex-wrap justify-start items-center gap-4 border-2 border-dashed border-[var(--color-border)] transition-colors w-max">
                                                                    {group.map(item => { const card = findCard(item.instanceId); if (!card) return null; return <CardDisplay key={`hand-${card.instanceId}`} card={card} size="small" quantity={item.quantity} draggable={true} onDragStart={(e) => handleDragStart(e, 'hand-card', { ...item, groupIndex })} onDrop={e => { e.preventDefault(); e.stopPropagation(); const droppedData = JSON.parse(e.dataTransfer.getData('text/plain')); if (droppedData.type === 'hand-card') handleReorder('hand', droppedData.data, { ...item, groupIndex }); }} onQuantityChange={(id, change) => setComboState({...comboState, startingHand: startingHand.map((g, i) => i === groupIndex ? g.map(it => it.instanceId === id ? {...it, quantity: Math.max(1, Math.min(3, it.quantity+change))} : it) : g)}, 'Update quantity')} onRemove={() => removeCardFromHand(card.instanceId, groupIndex)} isHighlighted={highlightedCardIds.includes(card.instanceId)} onMouseEnter={handleCardMouseEnter} onMouseLeave={handleCardMouseLeave} onMouseMove={handleCardMouseMove} /> })}
                                                                    {group.length === 0 && <p className="text-[var(--color-text-muted)] text-center w-full">{t('startingHandPlaceholder')}</p>}
                                                                    <CardSelector cardPool={cardPool.filter(p => !group.find(c => c.instanceId === p.instanceId))} onCardSelected={(card) => { const newHands = [...startingHand]; newHands[groupIndex].push({instanceId: card.instanceId, quantity: 1}); setComboState({...comboState, startingHand: newHands}, "Added card to hand") }} displayAs="card-placeholder" t={t} preferredDirection="side" />
                                                                </div>
                                                            </div>
                                                            {groupIndex < startingHand.length - 1 && <div className="self-center font-bold text-2xl text-violet-400 px-2">{t('or')}</div>}
                                                        </React.Fragment>
                                                    ))}
                                                </div>
                                                <button onClick={() => setComboState({...comboState, startingHand: [...startingHand, []]}, 'Add alternate hand')} className="btn px-3 py-1 bg-[var(--color-primary)] text-white text-sm font-semibold rounded-lg hover:bg-[var(--color-primary-hover)]">{t('addAlternateHand')}</button>
                                            </div>
                                        </div>
                                    </section>
                                    <section id="combo-steps-section" className="bg-[var(--color-surface)]/30 p-4 rounded-lg border border-[var(--color-border)]/30 combo-steps">
                                        <div className="flex justify-between items-center mb-4">
                                            <h3 className="text-xl font-semibold text-[var(--color-secondary)]">{t('comboStepsTitle')}</h3>
                                            <div>
                                                <button onClick={() => setComboState({...comboState, comboSteps: [...comboSteps, { type: 'group', id: generateId(), title: 'New Group' }]}, 'Added group')} className="btn px-3 py-1 bg-slate-600 text-white text-sm font-semibold rounded-lg hover:bg-slate-500 mr-2">{t('addGroup')}</button>
                                            </div>
                                        </div>
                                        <div className="grid gap-4 grid-cols-[repeat(auto-fill,minmax(18rem,1fr))]" data-drop-area="comboSteps" onDragOver={(e) => e.preventDefault()} onDrop={(e) => handleDrop(e, 'comboSteps')}>
                                            {comboSteps.map((step, index) => { 
                                                if (step.type === 'group') {
                                                    return (
                                                        <div 
                                                            key={step.id} 
                                                            className="col-span-full flex items-center gap-2 p-2 rounded-lg hover:bg-slate-700/50 cursor-move"
                                                            draggable={true}
                                                            onDragStart={e => { e.stopPropagation(); handleDragStart(e, 'step', step); }}
                                                            onDragEnd={handleDragEnd}
                                                            onDrop={e => { e.preventDefault(); e.stopPropagation(); const d = JSON.parse(e.dataTransfer.getData('text/plain')); if (d.type === 'step') handleReorder('step', d.data, step); setDragOverIndex(null); }}
                                                            onDragOver={e => { e.preventDefault(); e.stopPropagation(); setDragOverIndex(index); }}
                                                        >
                                                            <i className="fas fa-grip-vertical text-slate-400"></i>
                                                            <input type="text" value={step.title} onChange={e => updateStep(step.id, { title: e.target.value })} placeholder={t('groupTitlePlaceholder')} className="flex-grow p-1 text-lg font-bold bg-transparent text-amber-300 placeholder-amber-400/50 focus:bg-slate-700/50 rounded-lg outline-none" />
                                                            <button onClick={() => deleteStep(step.id)} className="text-slate-400 hover:text-red-500"><i className="fas fa-trash"></i></button>
                                                        </div>
                                                    )
                                                }
                                                if (step.type === 'note') {
                                                    return (
                                                        <div 
                                                            key={step.id} 
                                                            className="w-full bg-yellow-900/20 rounded-lg p-3 flex flex-col gap-2 relative border border-yellow-700/50 h-full"
                                                            draggable={true}
                                                            onDragStart={e => { e.stopPropagation(); handleDragStart(e, 'step', step); }}
                                                            onDragEnd={handleDragEnd}
                                                            onDrop={e => { e.preventDefault(); e.stopPropagation(); const d = JSON.parse(e.dataTransfer.getData('text/plain')); if (d.type === 'step') handleReorder('step', d.data, step); setDragOverIndex(null); }}
                                                            onDragOver={e => { e.preventDefault(); e.stopPropagation(); setDragOverIndex(index); }}
                                                        >
                                                            <div className="absolute top-2 right-2 flex gap-1 z-20">
                                                                <div className="cursor-move text-yellow-400" draggable={true}><i className="fas fa-grip-vertical"></i></div>
                                                                <button onClick={() => deleteStep(step.id)} className="text-slate-400 hover:text-red-500"><i className="fas fa-trash"></i></button>
                                                            </div>
                                                            <div className="flex items-center gap-2 self-start">
                                                                <i className="fas fa-sticky-note text-yellow-400"></i>
                                                                <span className="font-bold text-yellow-300">{t('addNote')}</span>
                                                            </div>
                                                            <AutoResizeTextarea
                                                                value={step.text}
                                                                onChange={e => updateStep(step.id, { text: e.target.value })}
                                                                placeholder="Escribe tu nota aquí..."
                                                                rows="1"
                                                                className="w-full h-full flex-grow p-1 text-sm bg-transparent text-yellow-200 placeholder-yellow-400/50 focus:bg-slate-700/50 rounded-lg outline-none resize-none"
                                                            />
                                                        </div>
                                                    );
                                                }
                                                const mainCard = findCard(step.mainCardInstanceId); 
                                                const isVulnerable = step.vulnerability?.text || (step.vulnerability?.cards && step.vulnerability.cards.length > 0); 
                                                const stepNumber = actualSteps.findIndex(s => s.id === step.id);
                                                return (
                                                <div 
                                                    key={step.id}
                                                    draggable={!step.isLocked}
                                                    onDragStart={e => { e.stopPropagation(); handleDragStart(e, 'step', step); }}
                                                    onDragEnd={handleDragEnd}
                                                    onDrop={e => { e.preventDefault(); e.stopPropagation(); const d = JSON.parse(e.dataTransfer.getData('text/plain')); if (d.type === 'step') handleReorder('step', d.data, step); setDragOverIndex(null); }}
                                                    onDragOver={e => { e.preventDefault(); e.stopPropagation(); setDragOverIndex(index); }}
                                                    onDragLeave={e => { e.stopPropagation(); }}
                                                    className={`combo-step-card w-full bg-[var(--color-surface)]/50 rounded-lg p-3 flex flex-col gap-2 relative border ${isVulnerable ? 'step-vulnerable border-red-500/50' : 'border-transparent'} ${!step.actionDescription ? 'step-incomplete' : ''} ${step.isLocked ? 'opacity-70' : ''}`} 
                                                    onMouseEnter={() => setHighlightedCardIds([step.mainCardInstanceId, ...step.targetCards.map(c => c.instanceId)])} 
                                                    onMouseLeave={() => setHighlightedCardIds([])}
                                                >
                                                    <div className="absolute top-2 right-2 flex gap-1 z-20">
                                                        <button onClick={() => updateStep(step.id, { vulnerability: { text: isVulnerable ? '' : 'Disrupción', cards: [] } })} className={`tutorial-vulnerability-btn p-1 rounded-full ${isVulnerable ? 'bg-red-500 text-white' : 'bg-slate-700 text-slate-400'} hover:bg-red-600`} data-tooltip="Marcar como vulnerable"><i className="fas fa-exclamation-triangle"></i></button>
                                                        <button onClick={() => setDeleteFromIndex(index)} className="p-1 rounded-full bg-slate-700 text-slate-400 hover:bg-red-600 hover:text-white" data-tooltip={t('undoFromHere')}><i className="fas fa-undo-alt"></i></button>
                                                        <button onClick={() => toggleStepLock(step.id)} className={`p-1 rounded-full ${step.isLocked ? 'bg-amber-500 text-white' : 'bg-slate-700 text-slate-400'} hover:bg-amber-600`} data-tooltip={step.isLocked ? t('unlockStep') : t('lockStep')}>{step.isLocked ? <i className="fas fa-lock"></i> : <i className="fas fa-unlock"></i>}</button>
                                                        <div className="cursor-move text-slate-400" draggable={!step.isLocked}><i className="fas fa-grip-vertical"></i></div>
                                                        <button onClick={() => deleteStep(step.id)} disabled={step.isLocked} className="text-slate-400 hover:text-red-500 disabled:opacity-50 disabled:cursor-not-allowed"><i className="fas fa-trash"></i></button>
                                                    </div>
                                                    <span className="font-bold text-[var(--color-text-muted)] self-start">{(language === 'en' ? 'Step' : t('stepLabel'))} {stepNumber + 1}</span>
                                                    <select value={step.actionType} onChange={e => updateStep(step.id, { actionType: e.target.value })} disabled={step.isLocked} className="tutorial-action-select bg-[var(--color-surface-light)] border border-[var(--color-border)] rounded p-1 text-sm font-semibold text-[var(--color-accent)] w-full disabled:opacity-50 disabled:cursor-not-allowed">{YGO_ACTIONS.map(act => <option key={act.name} value={act.name}>{act.emoji} {act.name}</option>)}</select>
                                                    {step.actionType === 'Other' && ( <input type="text" value={step.customActionText || ''} onChange={e => updateStep(step.id, { customActionText: sanitizeHTML(e.target.value) })} disabled={step.isLocked} placeholder="Especificar acción..." className="w-full bg-[var(--color-surface-light)] border border-[var(--color-border)] rounded p-1 text-xs text-center mt-1" /> )}
                                                    <div className="flex justify-center my-2 relative"><CardDisplay card={mainCard} size="medium" onClick={c => setSelectedCardForZoom(c)} isHighlighted={highlightedCardIds.includes(step.mainCardInstanceId)} onMouseEnter={handleCardMouseEnter} onMouseLeave={handleCardMouseLeave} onMouseMove={handleCardMouseMove} />{step.vulnerability?.cards && step.vulnerability.cards.length > 0 && (<div className="absolute -right-4 -top-2 z-10 flex flex-col items-end gap-1">{step.vulnerability.cards.map((vCard) => (<CardDisplay key={vCard.instanceId} card={findCard(vCard.instanceId)} size="tiny" useCropped={true} onRemove={!step.isLocked ? () => { const newVCards = step.vulnerability.cards.filter(c => c.instanceId !== vCard.instanceId); updateStep(step.id, { vulnerability: { ...step.vulnerability, cards: newVCards } }); } : null} onMouseEnter={handleCardMouseEnter} onMouseLeave={handleCardMouseLeave} onMouseMove={handleCardMouseMove}><span className="absolute top-0 right-0 text-xl z-10 -mt-1 -mr-1" style={{textShadow: '0 0 3px black'}}>⚠️</span></CardDisplay>))}</div>)}</div>
                                                    <button onClick={() => setZonePickerStepId(step.id)} className="btn text-xs py-1 px-2 bg-slate-600 hover:bg-slate-500 mb-2">{step.location ? ZONE_ABBREVIATIONS[step.location] : t('location')}</button>
                                                    {isVulnerable && (<div className="flex items-center gap-2 w-full">{(!step.vulnerability.cards || step.vulnerability.cards.length === 0) && (<input type="text" value={step.vulnerability.text} onChange={e => updateStep(step.id, { vulnerability: {...step.vulnerability, text: sanitizeHTML(e.target.value)} })} disabled={step.isLocked} placeholder="Vulnerable a..." className="flex-grow bg-red-900/50 border border-red-500/50 text-red-300 placeholder-red-400 rounded p-1 text-xs text-center disabled:opacity-50"/>)}<CardSelector cardPool={cardPool} onCardSelected={card => { const newVCard = { instanceId: card.instanceId }; const currentVCards = step.vulnerability?.cards || []; if (!currentVCards.some(c => c.instanceId === newVCard.instanceId)) { updateStep(step.id, { vulnerability: { ...step.vulnerability, cards: [...currentVCards, newVCard] } }); } }} displayAs="small-button" t={t} preferredDirection="side" /></div>)}
                                                    <div className="flex flex-wrap justify-center gap-1 border-t border-[var(--color-border)] pt-2 min-h-[4.5rem]">{step.targetCards.map(target => (<CardDisplay key={`target-${target.instanceId}`} card={findCard(target.instanceId)} size="tiny" isHighlighted={highlightedCardIds.includes(target.instanceId)} onRemove={!step.isLocked ? () => removeTargetCardFromStep(step.id, target.instanceId) : null} onMouseEnter={handleCardMouseEnter} onMouseLeave={handleCardMouseLeave} onMouseMove={handleCardMouseMove} />))}<CardSelector wrapperClassName="tutorial-add-target-btn" cardPool={cardPool} onCardSelected={card => updateStep(step.id, { targetCards: [...step.targetCards, {instanceId: card.instanceId, quantity: 1}]})} displayAs="small-button" t={t} preferredDirection="side" /></div>
                                                    <AutoResizeTextarea
                                                        value={step.actionDescription}
                                                        onChange={e => updateStep(step.id, { actionDescription: sanitizeHTML(e.target.value) })}
                                                        disabled={step.isLocked}
                                                        placeholder={t('stepDescribeAction')}
                                                        rows="1"
                                                        className="tutorial-description-input w-full bg-transparent mt-auto p-1 border-b border-[var(--color-border)] focus:border-[var(--color-primary)] outline-none text-xs text-center disabled:opacity-50 resize-none break-all"
                                                    />
                                                </div>
                                            )})}
                                            <div className="flex items-center justify-center w-full min-h-[18rem]" onDragOver={(e) => {e.preventDefault(); setDragOverIndex(comboSteps.length);}}><CardSelector cardPool={cardPool} onCardSelected={handleAddStepOrNote} displayAs="card-placeholder" t={t} preferredDirection="side" /></div>
                                        </div>
                                    </section>
                                    <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                                        <section className="bg-[var(--color-surface)]/30 p-4 rounded-lg border border-[var(--color-border)]/30 final-board">
                                            <h3 onClick={() => setIsFinalBoardOpen(!isFinalBoardOpen)} className="text-xl font-semibold text-[var(--color-secondary)] mb-3 flex justify-between items-center cursor-pointer hover:bg-[var(--color-surface)]/50 transition-colors">
                                                <span>
                                                    {t('finalBoardTitle')}
                                                    {disruptionCount > 0 && (
                                                        <span className="text-lg text-red-400 ml-2">({disruptionCount} {t('finalBoardDisruption')})</span>
                                                    )}
                                                </span>
                                                <i className={`fas fa-chevron-down transition-transform duration-300 ${isFinalBoardOpen ? '' : '-rotate-90'}`}></i>
                                            </h3>
                                             <div className={`transition-[max-height] duration-500 ease-in-out ${isFinalBoardOpen ? 'max-h-[40rem] overflow-visible' : 'max-h-0 overflow-hidden'}`}>
                                                <div data-drop-area="finalBoard" onDragOver={(e) => {e.preventDefault(); e.currentTarget.classList.add('drag-over')}} onDragLeave={(e) => e.currentTarget.classList.remove('drag-over')} onDrop={(e) => handleDrop(e, 'finalBoard')} className={`drop-zone p-4 bg-black/20 rounded-lg min-h-[11rem] flex flex-wrap gap-4 border-2 border-dashed border-[var(--color-border)] ${finalBoardCards.length === 0 ? 'justify-center items-center' : 'justify-start items-start'}`}>
                                                    {finalBoardCards.map(item => (
                                                        <div key={item.id} className="flex flex-col items-center gap-1 w-28" draggable={true} onDragStart={e => handleDragStart(e, 'board-card', item)} onDrop={e => { e.preventDefault(); e.stopPropagation(); const d = JSON.parse(e.dataTransfer.getData('text/plain')); if (d.type === 'board-card') handleReorder('board', d.data, item); }}>
                                                            <CardDisplay card={item.card} size="small" onClick={c => setSelectedCardForZoom(c)} onRemove={() => removeCardFromFinalBoard(item.id)} isHighlighted={highlightedCardIds.includes(item.card.instanceId)} onMouseEnter={handleCardMouseEnter} onMouseLeave={handleCardMouseLeave} onMouseMove={handleCardMouseMove} />
                                                            <select value={item.zone} onChange={e => updateFinalBoardCard(item.id, { zone: e.target.value })} className="bg-[var(--color-surface-light)] border border-[var(--color-border)] rounded p-1 text-xs w-full">{YGO_ZONES.map(zone => <option key={zone} value={zone}>{zone}</option>)}</select>
                                                            <label className="flex items-center justify-center gap-1.5 text-xs mt-1 cursor-pointer text-[var(--color-text-muted)] hover:text-[var(--color-text)]">
                                                                <input type="checkbox" checked={item.isDisruption || false} onChange={() => updateFinalBoardCard(item.id, { isDisruption: !item.isDisruption })} className="h-4 w-4 bg-slate-600 border-slate-500 text-violet-500 focus:ring-violet-500 rounded" />
                                                                {t('finalBoardDisruption')}
                                                            </label>
                                                        </div>
                                                    ))}
                                                    <CardSelector cardPool={cardPool.filter(p => !finalBoardCards.find(fb => fb.card.instanceId === p.instanceId))} onCardSelected={addCardToFinalBoard} displayAs="card-placeholder" t={t} preferredDirection="up" />
                                                </div>
                                            </div>
                                        </section>
                                        <section className="bg-[var(--color-surface)]/30 p-4 rounded-lg border border-[var(--color-border)]/30 notes-section">
                                            <h3 className="text-xl font-semibold text-[var(--color-secondary)] mb-3">{t('notesTitle')}</h3>
                                            <RichTextEditor value={notes} onChange={newNotes => setComboState({...comboState, notes: newNotes}, "Updated notes")} />
                                        </section>
                                    </div>
                                </div>
                            </div>
                        </main>
                    </div>
                </React.Fragment>
            );
        };
        
        const root = createRoot(document.getElementById('app-container'));
        root.render(<App />);

    </script>
    <a href="./community.html" 
   style="position:fixed;top:12px;right:12px;z-index:99999;
          background:#4da3ff;color:#001730;font-weight:700;
          text-decoration:none;padding:10px 14px;border-radius:10px;
          box-shadow:0 6px 18px rgba(0,0,0,.25);"
   title="Ver combos de la comunidad">
  Community
</a>
</body>
</html>


